!function (t, e) { "object" == typeof exports && "object" == typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define([], e) : "object" == typeof exports ? exports.MarkdownItDrawioViewer = e() : t.MarkdownItDrawioViewer = e() }(this, (function () {
    return function (t) { var e = {}; function n(r) { if (e[r]) return e[r].exports; var i = e[r] = { i: r, l: !1, exports: {} }; return t[r].call(i.exports, i, i.exports, n), i.l = !0, i.exports } return n.m = t, n.c = e, n.d = function (t, e, r) { n.o(t, e) || Object.defineProperty(t, e, { enumerable: !0, get: r }) }, n.r = function (t) { "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t, "__esModule", { value: !0 }) }, n.t = function (t, e) { if (1 & e && (t = n(t)), 8 & e) return t; if (4 & e && "object" == typeof t && t && t.__esModule) return t; var r = Object.create(null); if (n.r(r), Object.defineProperty(r, "default", { enumerable: !0, value: t }), 2 & e && "string" != typeof t) for (var i in t) n.d(r, i, function (e) { return t[e] }.bind(null, i)); return r }, n.n = function (t) { var e = t && t.__esModule ? function () { return t.default } : function () { return t }; return n.d(e, "a", e), e }, n.o = function (t, e) { return Object.prototype.hasOwnProperty.call(t, e) }, n.p = "", n(n.s = 25) }([function (t, e, n) { "use strict"; var r = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Int32Array; function i(t, e) { return Object.prototype.hasOwnProperty.call(t, e) } e.assign = function (t) { for (var e = Array.prototype.slice.call(arguments, 1); e.length;) { var n = e.shift(); if (n) { if ("object" != typeof n) throw new TypeError(n + "must be non-object"); for (var r in n) i(n, r) && (t[r] = n[r]) } } return t }, e.shrinkBuf = function (t, e) { return t.length === e ? t : t.subarray ? t.subarray(0, e) : (t.length = e, t) }; var a = { arraySet: function (t, e, n, r, i) { if (e.subarray && t.subarray) t.set(e.subarray(n, n + r), i); else for (var a = 0; a < r; a++)t[i + a] = e[n + a] }, flattenChunks: function (t) { var e, n, r, i, a, o; for (r = 0, e = 0, n = t.length; e < n; e++)r += t[e].length; for (o = new Uint8Array(r), i = 0, e = 0, n = t.length; e < n; e++)a = t[e], o.set(a, i), i += a.length; return o } }, o = { arraySet: function (t, e, n, r, i) { for (var a = 0; a < r; a++)t[i + a] = e[n + a] }, flattenChunks: function (t) { return [].concat.apply([], t) } }; e.setTyped = function (t) { t ? (e.Buf8 = Uint8Array, e.Buf16 = Uint16Array, e.Buf32 = Int32Array, e.assign(e, a)) : (e.Buf8 = Array, e.Buf16 = Array, e.Buf32 = Array, e.assign(e, o)) }, e.setTyped(r) }, function (t, e) { var n; n = function () { return this }(); try { n = n || new Function("return this")() } catch (t) { "object" == typeof window && (n = window) } t.exports = n }, function (t, e, n) { "use strict"; var r = n(7), i = Object.keys || function (t) { var e = []; for (var n in t) e.push(n); return e }; t.exports = f; var a = Object.create(n(5)); a.inherits = n(3); var o = n(21), s = n(12); a.inherits(f, o); for (var u = i(s.prototype), h = 0; h < u.length; h++) { var l = u[h]; f.prototype[l] || (f.prototype[l] = s.prototype[l]) } function f(t) { if (!(this instanceof f)) return new f(t); o.call(this, t), s.call(this, t), t && !1 === t.readable && (this.readable = !1), t && !1 === t.writable && (this.writable = !1), this.allowHalfOpen = !0, t && !1 === t.allowHalfOpen && (this.allowHalfOpen = !1), this.once("end", c) } function c() { this.allowHalfOpen || this._writableState.ended || r.nextTick(d, this) } function d(t) { t.end() } Object.defineProperty(f.prototype, "writableHighWaterMark", { enumerable: !1, get: function () { return this._writableState.highWaterMark } }), Object.defineProperty(f.prototype, "destroyed", { get: function () { return void 0 !== this._readableState && void 0 !== this._writableState && (this._readableState.destroyed && this._writableState.destroyed) }, set: function (t) { void 0 !== this._readableState && void 0 !== this._writableState && (this._readableState.destroyed = t, this._writableState.destroyed = t) } }), f.prototype._destroy = function (t, e) { this.push(null), this.end(), r.nextTick(e, t) } }, function (t, e) { "function" == typeof Object.create ? t.exports = function (t, e) { e && (t.super_ = e, t.prototype = Object.create(e.prototype, { constructor: { value: t, enumerable: !1, writable: !0, configurable: !0 } })) } : t.exports = function (t, e) { if (e) { t.super_ = e; var n = function () { }; n.prototype = e.prototype, t.prototype = new n, t.prototype.constructor = t } } }, function (t, e, n) {
        "use strict"; (function (t) {
            /*!
             * The buffer module from node.js, for the browser.
             *
             * @author   Feross Aboukhadijeh <http://feross.org>
             * @license  MIT
             */
            var r = n(27), i = n(28), a = n(14); function o() { return u.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823 } function s(t, e) { if (o() < e) throw new RangeError("Invalid typed array length"); return u.TYPED_ARRAY_SUPPORT ? (t = new Uint8Array(e)).__proto__ = u.prototype : (null === t && (t = new u(e)), t.length = e), t } function u(t, e, n) { if (!(u.TYPED_ARRAY_SUPPORT || this instanceof u)) return new u(t, e, n); if ("number" == typeof t) { if ("string" == typeof e) throw new Error("If encoding is specified then the first argument must be a string"); return f(this, t) } return h(this, t, e, n) } function h(t, e, n, r) { if ("number" == typeof e) throw new TypeError('"value" argument must not be a number'); return "undefined" != typeof ArrayBuffer && e instanceof ArrayBuffer ? function (t, e, n, r) { if (e.byteLength, n < 0 || e.byteLength < n) throw new RangeError("'offset' is out of bounds"); if (e.byteLength < n + (r || 0)) throw new RangeError("'length' is out of bounds"); e = void 0 === n && void 0 === r ? new Uint8Array(e) : void 0 === r ? new Uint8Array(e, n) : new Uint8Array(e, n, r); u.TYPED_ARRAY_SUPPORT ? (t = e).__proto__ = u.prototype : t = c(t, e); return t }(t, e, n, r) : "string" == typeof e ? function (t, e, n) { "string" == typeof n && "" !== n || (n = "utf8"); if (!u.isEncoding(n)) throw new TypeError('"encoding" must be a valid string encoding'); var r = 0 | p(e, n), i = (t = s(t, r)).write(e, n); i !== r && (t = t.slice(0, i)); return t }(t, e, n) : function (t, e) { if (u.isBuffer(e)) { var n = 0 | d(e.length); return 0 === (t = s(t, n)).length ? t : (e.copy(t, 0, 0, n), t) } if (e) { if ("undefined" != typeof ArrayBuffer && e.buffer instanceof ArrayBuffer || "length" in e) return "number" != typeof e.length || (r = e.length) != r ? s(t, 0) : c(t, e); if ("Buffer" === e.type && a(e.data)) return c(t, e.data) } var r; throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.") }(t, e) } function l(t) { if ("number" != typeof t) throw new TypeError('"size" argument must be a number'); if (t < 0) throw new RangeError('"size" argument must not be negative') } function f(t, e) { if (l(e), t = s(t, e < 0 ? 0 : 0 | d(e)), !u.TYPED_ARRAY_SUPPORT) for (var n = 0; n < e; ++n)t[n] = 0; return t } function c(t, e) { var n = e.length < 0 ? 0 : 0 | d(e.length); t = s(t, n); for (var r = 0; r < n; r += 1)t[r] = 255 & e[r]; return t } function d(t) { if (t >= o()) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + o().toString(16) + " bytes"); return 0 | t } function p(t, e) { if (u.isBuffer(t)) return t.length; if ("undefined" != typeof ArrayBuffer && "function" == typeof ArrayBuffer.isView && (ArrayBuffer.isView(t) || t instanceof ArrayBuffer)) return t.byteLength; "string" != typeof t && (t = "" + t); var n = t.length; if (0 === n) return 0; for (var r = !1; ;)switch (e) { case "ascii": case "latin1": case "binary": return n; case "utf8": case "utf-8": case void 0: return z(t).length; case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return 2 * n; case "hex": return n >>> 1; case "base64": return j(t).length; default: if (r) return z(t).length; e = ("" + e).toLowerCase(), r = !0 } } function g(t, e, n) { var r = !1; if ((void 0 === e || e < 0) && (e = 0), e > this.length) return ""; if ((void 0 === n || n > this.length) && (n = this.length), n <= 0) return ""; if ((n >>>= 0) <= (e >>>= 0)) return ""; for (t || (t = "utf8"); ;)switch (t) { case "hex": return C(this, e, n); case "utf8": case "utf-8": return S(this, e, n); case "ascii": return A(this, e, n); case "latin1": case "binary": return N(this, e, n); case "base64": return x(this, e, n); case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return I(this, e, n); default: if (r) throw new TypeError("Unknown encoding: " + t); t = (t + "").toLowerCase(), r = !0 } } function _(t, e, n) { var r = t[e]; t[e] = t[n], t[n] = r } function m(t, e, n, r, i) { if (0 === t.length) return -1; if ("string" == typeof n ? (r = n, n = 0) : n > 2147483647 ? n = 2147483647 : n < -2147483648 && (n = -2147483648), n = +n, isNaN(n) && (n = i ? 0 : t.length - 1), n < 0 && (n = t.length + n), n >= t.length) { if (i) return -1; n = t.length - 1 } else if (n < 0) { if (!i) return -1; n = 0 } if ("string" == typeof e && (e = u.from(e, r)), u.isBuffer(e)) return 0 === e.length ? -1 : b(t, e, n, r, i); if ("number" == typeof e) return e &= 255, u.TYPED_ARRAY_SUPPORT && "function" == typeof Uint8Array.prototype.indexOf ? i ? Uint8Array.prototype.indexOf.call(t, e, n) : Uint8Array.prototype.lastIndexOf.call(t, e, n) : b(t, [e], n, r, i); throw new TypeError("val must be string, number or Buffer") } function b(t, e, n, r, i) { var a, o = 1, s = t.length, u = e.length; if (void 0 !== r && ("ucs2" === (r = String(r).toLowerCase()) || "ucs-2" === r || "utf16le" === r || "utf-16le" === r)) { if (t.length < 2 || e.length < 2) return -1; o = 2, s /= 2, u /= 2, n /= 2 } function h(t, e) { return 1 === o ? t[e] : t.readUInt16BE(e * o) } if (i) { var l = -1; for (a = n; a < s; a++)if (h(t, a) === h(e, -1 === l ? 0 : a - l)) { if (-1 === l && (l = a), a - l + 1 === u) return l * o } else -1 !== l && (a -= a - l), l = -1 } else for (n + u > s && (n = s - u), a = n; a >= 0; a--) { for (var f = !0, c = 0; c < u; c++)if (h(t, a + c) !== h(e, c)) { f = !1; break } if (f) return a } return -1 } function w(t, e, n, r) { n = Number(n) || 0; var i = t.length - n; r ? (r = Number(r)) > i && (r = i) : r = i; var a = e.length; if (a % 2 != 0) throw new TypeError("Invalid hex string"); r > a / 2 && (r = a / 2); for (var o = 0; o < r; ++o) { var s = parseInt(e.substr(2 * o, 2), 16); if (isNaN(s)) return o; t[n + o] = s } return o } function v(t, e, n, r) { return Y(z(e, t.length - n), t, n, r) } function y(t, e, n, r) { return Y(function (t) { for (var e = [], n = 0; n < t.length; ++n)e.push(255 & t.charCodeAt(n)); return e }(e), t, n, r) } function T(t, e, n, r) { return y(t, e, n, r) } function E(t, e, n, r) { return Y(j(e), t, n, r) } function k(t, e, n, r) { return Y(function (t, e) { for (var n, r, i, a = [], o = 0; o < t.length && !((e -= 2) < 0); ++o)n = t.charCodeAt(o), r = n >> 8, i = n % 256, a.push(i), a.push(r); return a }(e, t.length - n), t, n, r) } function x(t, e, n) { return 0 === e && n === t.length ? r.fromByteArray(t) : r.fromByteArray(t.slice(e, n)) } function S(t, e, n) { n = Math.min(t.length, n); for (var r = [], i = e; i < n;) { var a, o, s, u, h = t[i], l = null, f = h > 239 ? 4 : h > 223 ? 3 : h > 191 ? 2 : 1; if (i + f <= n) switch (f) { case 1: h < 128 && (l = h); break; case 2: 128 == (192 & (a = t[i + 1])) && (u = (31 & h) << 6 | 63 & a) > 127 && (l = u); break; case 3: a = t[i + 1], o = t[i + 2], 128 == (192 & a) && 128 == (192 & o) && (u = (15 & h) << 12 | (63 & a) << 6 | 63 & o) > 2047 && (u < 55296 || u > 57343) && (l = u); break; case 4: a = t[i + 1], o = t[i + 2], s = t[i + 3], 128 == (192 & a) && 128 == (192 & o) && 128 == (192 & s) && (u = (15 & h) << 18 | (63 & a) << 12 | (63 & o) << 6 | 63 & s) > 65535 && u < 1114112 && (l = u) }null === l ? (l = 65533, f = 1) : l > 65535 && (l -= 65536, r.push(l >>> 10 & 1023 | 55296), l = 56320 | 1023 & l), r.push(l), i += f } return function (t) { var e = t.length; if (e <= 4096) return String.fromCharCode.apply(String, t); var n = "", r = 0; for (; r < e;)n += String.fromCharCode.apply(String, t.slice(r, r += 4096)); return n }(r) } e.Buffer = u, e.SlowBuffer = function (t) { +t != t && (t = 0); return u.alloc(+t) }, e.INSPECT_MAX_BYTES = 50, u.TYPED_ARRAY_SUPPORT = void 0 !== t.TYPED_ARRAY_SUPPORT ? t.TYPED_ARRAY_SUPPORT : function () { try { var t = new Uint8Array(1); return t.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }, 42 === t.foo() && "function" == typeof t.subarray && 0 === t.subarray(1, 1).byteLength } catch (t) { return !1 } }(), e.kMaxLength = o(), u.poolSize = 8192, u._augment = function (t) { return t.__proto__ = u.prototype, t }, u.from = function (t, e, n) { return h(null, t, e, n) }, u.TYPED_ARRAY_SUPPORT && (u.prototype.__proto__ = Uint8Array.prototype, u.__proto__ = Uint8Array, "undefined" != typeof Symbol && Symbol.species && u[Symbol.species] === u && Object.defineProperty(u, Symbol.species, { value: null, configurable: !0 })), u.alloc = function (t, e, n) { return function (t, e, n, r) { return l(e), e <= 0 ? s(t, e) : void 0 !== n ? "string" == typeof r ? s(t, e).fill(n, r) : s(t, e).fill(n) : s(t, e) }(null, t, e, n) }, u.allocUnsafe = function (t) { return f(null, t) }, u.allocUnsafeSlow = function (t) { return f(null, t) }, u.isBuffer = function (t) { return !(null == t || !t._isBuffer) }, u.compare = function (t, e) { if (!u.isBuffer(t) || !u.isBuffer(e)) throw new TypeError("Arguments must be Buffers"); if (t === e) return 0; for (var n = t.length, r = e.length, i = 0, a = Math.min(n, r); i < a; ++i)if (t[i] !== e[i]) { n = t[i], r = e[i]; break } return n < r ? -1 : r < n ? 1 : 0 }, u.isEncoding = function (t) { switch (String(t).toLowerCase()) { case "hex": case "utf8": case "utf-8": case "ascii": case "latin1": case "binary": case "base64": case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return !0; default: return !1 } }, u.concat = function (t, e) { if (!a(t)) throw new TypeError('"list" argument must be an Array of Buffers'); if (0 === t.length) return u.alloc(0); var n; if (void 0 === e) for (e = 0, n = 0; n < t.length; ++n)e += t[n].length; var r = u.allocUnsafe(e), i = 0; for (n = 0; n < t.length; ++n) { var o = t[n]; if (!u.isBuffer(o)) throw new TypeError('"list" argument must be an Array of Buffers'); o.copy(r, i), i += o.length } return r }, u.byteLength = p, u.prototype._isBuffer = !0, u.prototype.swap16 = function () { var t = this.length; if (t % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits"); for (var e = 0; e < t; e += 2)_(this, e, e + 1); return this }, u.prototype.swap32 = function () { var t = this.length; if (t % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits"); for (var e = 0; e < t; e += 4)_(this, e, e + 3), _(this, e + 1, e + 2); return this }, u.prototype.swap64 = function () { var t = this.length; if (t % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits"); for (var e = 0; e < t; e += 8)_(this, e, e + 7), _(this, e + 1, e + 6), _(this, e + 2, e + 5), _(this, e + 3, e + 4); return this }, u.prototype.toString = function () { var t = 0 | this.length; return 0 === t ? "" : 0 === arguments.length ? S(this, 0, t) : g.apply(this, arguments) }, u.prototype.equals = function (t) { if (!u.isBuffer(t)) throw new TypeError("Argument must be a Buffer"); return this === t || 0 === u.compare(this, t) }, u.prototype.inspect = function () { var t = "", n = e.INSPECT_MAX_BYTES; return this.length > 0 && (t = this.toString("hex", 0, n).match(/.{2}/g).join(" "), this.length > n && (t += " ... ")), "<Buffer " + t + ">" }, u.prototype.compare = function (t, e, n, r, i) { if (!u.isBuffer(t)) throw new TypeError("Argument must be a Buffer"); if (void 0 === e && (e = 0), void 0 === n && (n = t ? t.length : 0), void 0 === r && (r = 0), void 0 === i && (i = this.length), e < 0 || n > t.length || r < 0 || i > this.length) throw new RangeError("out of range index"); if (r >= i && e >= n) return 0; if (r >= i) return -1; if (e >= n) return 1; if (this === t) return 0; for (var a = (i >>>= 0) - (r >>>= 0), o = (n >>>= 0) - (e >>>= 0), s = Math.min(a, o), h = this.slice(r, i), l = t.slice(e, n), f = 0; f < s; ++f)if (h[f] !== l[f]) { a = h[f], o = l[f]; break } return a < o ? -1 : o < a ? 1 : 0 }, u.prototype.includes = function (t, e, n) { return -1 !== this.indexOf(t, e, n) }, u.prototype.indexOf = function (t, e, n) { return m(this, t, e, n, !0) }, u.prototype.lastIndexOf = function (t, e, n) { return m(this, t, e, n, !1) }, u.prototype.write = function (t, e, n, r) { if (void 0 === e) r = "utf8", n = this.length, e = 0; else if (void 0 === n && "string" == typeof e) r = e, n = this.length, e = 0; else { if (!isFinite(e)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported"); e |= 0, isFinite(n) ? (n |= 0, void 0 === r && (r = "utf8")) : (r = n, n = void 0) } var i = this.length - e; if ((void 0 === n || n > i) && (n = i), t.length > 0 && (n < 0 || e < 0) || e > this.length) throw new RangeError("Attempt to write outside buffer bounds"); r || (r = "utf8"); for (var a = !1; ;)switch (r) { case "hex": return w(this, t, e, n); case "utf8": case "utf-8": return v(this, t, e, n); case "ascii": return y(this, t, e, n); case "latin1": case "binary": return T(this, t, e, n); case "base64": return E(this, t, e, n); case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return k(this, t, e, n); default: if (a) throw new TypeError("Unknown encoding: " + r); r = ("" + r).toLowerCase(), a = !0 } }, u.prototype.toJSON = function () { return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) } }; function A(t, e, n) { var r = ""; n = Math.min(t.length, n); for (var i = e; i < n; ++i)r += String.fromCharCode(127 & t[i]); return r } function N(t, e, n) { var r = ""; n = Math.min(t.length, n); for (var i = e; i < n; ++i)r += String.fromCharCode(t[i]); return r } function C(t, e, n) { var r = t.length; (!e || e < 0) && (e = 0), (!n || n < 0 || n > r) && (n = r); for (var i = "", a = e; a < n; ++a)i += F(t[a]); return i } function I(t, e, n) { for (var r = t.slice(e, n), i = "", a = 0; a < r.length; a += 2)i += String.fromCharCode(r[a] + 256 * r[a + 1]); return i } function R(t, e, n) { if (t % 1 != 0 || t < 0) throw new RangeError("offset is not uint"); if (t + e > n) throw new RangeError("Trying to access beyond buffer length") } function O(t, e, n, r, i, a) { if (!u.isBuffer(t)) throw new TypeError('"buffer" argument must be a Buffer instance'); if (e > i || e < a) throw new RangeError('"value" argument is out of bounds'); if (n + r > t.length) throw new RangeError("Index out of range") } function D(t, e, n, r) { e < 0 && (e = 65535 + e + 1); for (var i = 0, a = Math.min(t.length - n, 2); i < a; ++i)t[n + i] = (e & 255 << 8 * (r ? i : 1 - i)) >>> 8 * (r ? i : 1 - i) } function B(t, e, n, r) { e < 0 && (e = 4294967295 + e + 1); for (var i = 0, a = Math.min(t.length - n, 4); i < a; ++i)t[n + i] = e >>> 8 * (r ? i : 3 - i) & 255 } function L(t, e, n, r, i, a) { if (n + r > t.length) throw new RangeError("Index out of range"); if (n < 0) throw new RangeError("Index out of range") } function P(t, e, n, r, a) { return a || L(t, 0, n, 4), i.write(t, e, n, r, 23, 4), n + 4 } function M(t, e, n, r, a) { return a || L(t, 0, n, 8), i.write(t, e, n, r, 52, 8), n + 8 } u.prototype.slice = function (t, e) { var n, r = this.length; if ((t = ~~t) < 0 ? (t += r) < 0 && (t = 0) : t > r && (t = r), (e = void 0 === e ? r : ~~e) < 0 ? (e += r) < 0 && (e = 0) : e > r && (e = r), e < t && (e = t), u.TYPED_ARRAY_SUPPORT) (n = this.subarray(t, e)).__proto__ = u.prototype; else { var i = e - t; n = new u(i, void 0); for (var a = 0; a < i; ++a)n[a] = this[a + t] } return n }, u.prototype.readUIntLE = function (t, e, n) { t |= 0, e |= 0, n || R(t, e, this.length); for (var r = this[t], i = 1, a = 0; ++a < e && (i *= 256);)r += this[t + a] * i; return r }, u.prototype.readUIntBE = function (t, e, n) { t |= 0, e |= 0, n || R(t, e, this.length); for (var r = this[t + --e], i = 1; e > 0 && (i *= 256);)r += this[t + --e] * i; return r }, u.prototype.readUInt8 = function (t, e) { return e || R(t, 1, this.length), this[t] }, u.prototype.readUInt16LE = function (t, e) { return e || R(t, 2, this.length), this[t] | this[t + 1] << 8 }, u.prototype.readUInt16BE = function (t, e) { return e || R(t, 2, this.length), this[t] << 8 | this[t + 1] }, u.prototype.readUInt32LE = function (t, e) { return e || R(t, 4, this.length), (this[t] | this[t + 1] << 8 | this[t + 2] << 16) + 16777216 * this[t + 3] }, u.prototype.readUInt32BE = function (t, e) { return e || R(t, 4, this.length), 16777216 * this[t] + (this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3]) }, u.prototype.readIntLE = function (t, e, n) { t |= 0, e |= 0, n || R(t, e, this.length); for (var r = this[t], i = 1, a = 0; ++a < e && (i *= 256);)r += this[t + a] * i; return r >= (i *= 128) && (r -= Math.pow(2, 8 * e)), r }, u.prototype.readIntBE = function (t, e, n) { t |= 0, e |= 0, n || R(t, e, this.length); for (var r = e, i = 1, a = this[t + --r]; r > 0 && (i *= 256);)a += this[t + --r] * i; return a >= (i *= 128) && (a -= Math.pow(2, 8 * e)), a }, u.prototype.readInt8 = function (t, e) { return e || R(t, 1, this.length), 128 & this[t] ? -1 * (255 - this[t] + 1) : this[t] }, u.prototype.readInt16LE = function (t, e) { e || R(t, 2, this.length); var n = this[t] | this[t + 1] << 8; return 32768 & n ? 4294901760 | n : n }, u.prototype.readInt16BE = function (t, e) { e || R(t, 2, this.length); var n = this[t + 1] | this[t] << 8; return 32768 & n ? 4294901760 | n : n }, u.prototype.readInt32LE = function (t, e) { return e || R(t, 4, this.length), this[t] | this[t + 1] << 8 | this[t + 2] << 16 | this[t + 3] << 24 }, u.prototype.readInt32BE = function (t, e) { return e || R(t, 4, this.length), this[t] << 24 | this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3] }, u.prototype.readFloatLE = function (t, e) { return e || R(t, 4, this.length), i.read(this, t, !0, 23, 4) }, u.prototype.readFloatBE = function (t, e) { return e || R(t, 4, this.length), i.read(this, t, !1, 23, 4) }, u.prototype.readDoubleLE = function (t, e) { return e || R(t, 8, this.length), i.read(this, t, !0, 52, 8) }, u.prototype.readDoubleBE = function (t, e) { return e || R(t, 8, this.length), i.read(this, t, !1, 52, 8) }, u.prototype.writeUIntLE = function (t, e, n, r) { (t = +t, e |= 0, n |= 0, r) || O(this, t, e, n, Math.pow(2, 8 * n) - 1, 0); var i = 1, a = 0; for (this[e] = 255 & t; ++a < n && (i *= 256);)this[e + a] = t / i & 255; return e + n }, u.prototype.writeUIntBE = function (t, e, n, r) { (t = +t, e |= 0, n |= 0, r) || O(this, t, e, n, Math.pow(2, 8 * n) - 1, 0); var i = n - 1, a = 1; for (this[e + i] = 255 & t; --i >= 0 && (a *= 256);)this[e + i] = t / a & 255; return e + n }, u.prototype.writeUInt8 = function (t, e, n) { return t = +t, e |= 0, n || O(this, t, e, 1, 255, 0), u.TYPED_ARRAY_SUPPORT || (t = Math.floor(t)), this[e] = 255 & t, e + 1 }, u.prototype.writeUInt16LE = function (t, e, n) { return t = +t, e |= 0, n || O(this, t, e, 2, 65535, 0), u.TYPED_ARRAY_SUPPORT ? (this[e] = 255 & t, this[e + 1] = t >>> 8) : D(this, t, e, !0), e + 2 }, u.prototype.writeUInt16BE = function (t, e, n) { return t = +t, e |= 0, n || O(this, t, e, 2, 65535, 0), u.TYPED_ARRAY_SUPPORT ? (this[e] = t >>> 8, this[e + 1] = 255 & t) : D(this, t, e, !1), e + 2 }, u.prototype.writeUInt32LE = function (t, e, n) { return t = +t, e |= 0, n || O(this, t, e, 4, 4294967295, 0), u.TYPED_ARRAY_SUPPORT ? (this[e + 3] = t >>> 24, this[e + 2] = t >>> 16, this[e + 1] = t >>> 8, this[e] = 255 & t) : B(this, t, e, !0), e + 4 }, u.prototype.writeUInt32BE = function (t, e, n) { return t = +t, e |= 0, n || O(this, t, e, 4, 4294967295, 0), u.TYPED_ARRAY_SUPPORT ? (this[e] = t >>> 24, this[e + 1] = t >>> 16, this[e + 2] = t >>> 8, this[e + 3] = 255 & t) : B(this, t, e, !1), e + 4 }, u.prototype.writeIntLE = function (t, e, n, r) { if (t = +t, e |= 0, !r) { var i = Math.pow(2, 8 * n - 1); O(this, t, e, n, i - 1, -i) } var a = 0, o = 1, s = 0; for (this[e] = 255 & t; ++a < n && (o *= 256);)t < 0 && 0 === s && 0 !== this[e + a - 1] && (s = 1), this[e + a] = (t / o >> 0) - s & 255; return e + n }, u.prototype.writeIntBE = function (t, e, n, r) { if (t = +t, e |= 0, !r) { var i = Math.pow(2, 8 * n - 1); O(this, t, e, n, i - 1, -i) } var a = n - 1, o = 1, s = 0; for (this[e + a] = 255 & t; --a >= 0 && (o *= 256);)t < 0 && 0 === s && 0 !== this[e + a + 1] && (s = 1), this[e + a] = (t / o >> 0) - s & 255; return e + n }, u.prototype.writeInt8 = function (t, e, n) { return t = +t, e |= 0, n || O(this, t, e, 1, 127, -128), u.TYPED_ARRAY_SUPPORT || (t = Math.floor(t)), t < 0 && (t = 255 + t + 1), this[e] = 255 & t, e + 1 }, u.prototype.writeInt16LE = function (t, e, n) { return t = +t, e |= 0, n || O(this, t, e, 2, 32767, -32768), u.TYPED_ARRAY_SUPPORT ? (this[e] = 255 & t, this[e + 1] = t >>> 8) : D(this, t, e, !0), e + 2 }, u.prototype.writeInt16BE = function (t, e, n) { return t = +t, e |= 0, n || O(this, t, e, 2, 32767, -32768), u.TYPED_ARRAY_SUPPORT ? (this[e] = t >>> 8, this[e + 1] = 255 & t) : D(this, t, e, !1), e + 2 }, u.prototype.writeInt32LE = function (t, e, n) { return t = +t, e |= 0, n || O(this, t, e, 4, 2147483647, -2147483648), u.TYPED_ARRAY_SUPPORT ? (this[e] = 255 & t, this[e + 1] = t >>> 8, this[e + 2] = t >>> 16, this[e + 3] = t >>> 24) : B(this, t, e, !0), e + 4 }, u.prototype.writeInt32BE = function (t, e, n) { return t = +t, e |= 0, n || O(this, t, e, 4, 2147483647, -2147483648), t < 0 && (t = 4294967295 + t + 1), u.TYPED_ARRAY_SUPPORT ? (this[e] = t >>> 24, this[e + 1] = t >>> 16, this[e + 2] = t >>> 8, this[e + 3] = 255 & t) : B(this, t, e, !1), e + 4 }, u.prototype.writeFloatLE = function (t, e, n) { return P(this, t, e, !0, n) }, u.prototype.writeFloatBE = function (t, e, n) { return P(this, t, e, !1, n) }, u.prototype.writeDoubleLE = function (t, e, n) { return M(this, t, e, !0, n) }, u.prototype.writeDoubleBE = function (t, e, n) { return M(this, t, e, !1, n) }, u.prototype.copy = function (t, e, n, r) { if (n || (n = 0), r || 0 === r || (r = this.length), e >= t.length && (e = t.length), e || (e = 0), r > 0 && r < n && (r = n), r === n) return 0; if (0 === t.length || 0 === this.length) return 0; if (e < 0) throw new RangeError("targetStart out of bounds"); if (n < 0 || n >= this.length) throw new RangeError("sourceStart out of bounds"); if (r < 0) throw new RangeError("sourceEnd out of bounds"); r > this.length && (r = this.length), t.length - e < r - n && (r = t.length - e + n); var i, a = r - n; if (this === t && n < e && e < r) for (i = a - 1; i >= 0; --i)t[i + e] = this[i + n]; else if (a < 1e3 || !u.TYPED_ARRAY_SUPPORT) for (i = 0; i < a; ++i)t[i + e] = this[i + n]; else Uint8Array.prototype.set.call(t, this.subarray(n, n + a), e); return a }, u.prototype.fill = function (t, e, n, r) { if ("string" == typeof t) { if ("string" == typeof e ? (r = e, e = 0, n = this.length) : "string" == typeof n && (r = n, n = this.length), 1 === t.length) { var i = t.charCodeAt(0); i < 256 && (t = i) } if (void 0 !== r && "string" != typeof r) throw new TypeError("encoding must be a string"); if ("string" == typeof r && !u.isEncoding(r)) throw new TypeError("Unknown encoding: " + r) } else "number" == typeof t && (t &= 255); if (e < 0 || this.length < e || this.length < n) throw new RangeError("Out of range index"); if (n <= e) return this; var a; if (e >>>= 0, n = void 0 === n ? this.length : n >>> 0, t || (t = 0), "number" == typeof t) for (a = e; a < n; ++a)this[a] = t; else { var o = u.isBuffer(t) ? t : z(new u(t, r).toString()), s = o.length; for (a = 0; a < n - e; ++a)this[a + e] = o[a % s] } return this }; var U = /[^+\/0-9A-Za-z-_]/g; function F(t) { return t < 16 ? "0" + t.toString(16) : t.toString(16) } function z(t, e) { var n; e = e || 1 / 0; for (var r = t.length, i = null, a = [], o = 0; o < r; ++o) { if ((n = t.charCodeAt(o)) > 55295 && n < 57344) { if (!i) { if (n > 56319) { (e -= 3) > -1 && a.push(239, 191, 189); continue } if (o + 1 === r) { (e -= 3) > -1 && a.push(239, 191, 189); continue } i = n; continue } if (n < 56320) { (e -= 3) > -1 && a.push(239, 191, 189), i = n; continue } n = 65536 + (i - 55296 << 10 | n - 56320) } else i && (e -= 3) > -1 && a.push(239, 191, 189); if (i = null, n < 128) { if ((e -= 1) < 0) break; a.push(n) } else if (n < 2048) { if ((e -= 2) < 0) break; a.push(n >> 6 | 192, 63 & n | 128) } else if (n < 65536) { if ((e -= 3) < 0) break; a.push(n >> 12 | 224, n >> 6 & 63 | 128, 63 & n | 128) } else { if (!(n < 1114112)) throw new Error("Invalid code point"); if ((e -= 4) < 0) break; a.push(n >> 18 | 240, n >> 12 & 63 | 128, n >> 6 & 63 | 128, 63 & n | 128) } } return a } function j(t) { return r.toByteArray(function (t) { if ((t = function (t) { return t.trim ? t.trim() : t.replace(/^\s+|\s+$/g, "") }(t).replace(U, "")).length < 2) return ""; for (; t.length % 4 != 0;)t += "="; return t }(t)) } function Y(t, e, n, r) { for (var i = 0; i < r && !(i + n >= e.length || i >= t.length); ++i)e[i + n] = t[i]; return i }
        }).call(this, n(1))
    }, function (t, e, n) { (function (t) { function n(t) { return Object.prototype.toString.call(t) } e.isArray = function (t) { return Array.isArray ? Array.isArray(t) : "[object Array]" === n(t) }, e.isBoolean = function (t) { return "boolean" == typeof t }, e.isNull = function (t) { return null === t }, e.isNullOrUndefined = function (t) { return null == t }, e.isNumber = function (t) { return "number" == typeof t }, e.isString = function (t) { return "string" == typeof t }, e.isSymbol = function (t) { return "symbol" == typeof t }, e.isUndefined = function (t) { return void 0 === t }, e.isRegExp = function (t) { return "[object RegExp]" === n(t) }, e.isObject = function (t) { return "object" == typeof t && null !== t }, e.isDate = function (t) { return "[object Date]" === n(t) }, e.isError = function (t) { return "[object Error]" === n(t) || t instanceof Error }, e.isFunction = function (t) { return "function" == typeof t }, e.isPrimitive = function (t) { return null === t || "boolean" == typeof t || "number" == typeof t || "string" == typeof t || "symbol" == typeof t || void 0 === t }, e.isBuffer = t.isBuffer }).call(this, n(4).Buffer) }, function (t, e) { var n, r, i = t.exports = {}; function a() { throw new Error("setTimeout has not been defined") } function o() { throw new Error("clearTimeout has not been defined") } function s(t) { if (n === setTimeout) return setTimeout(t, 0); if ((n === a || !n) && setTimeout) return n = setTimeout, setTimeout(t, 0); try { return n(t, 0) } catch (e) { try { return n.call(null, t, 0) } catch (e) { return n.call(this, t, 0) } } } !function () { try { n = "function" == typeof setTimeout ? setTimeout : a } catch (t) { n = a } try { r = "function" == typeof clearTimeout ? clearTimeout : o } catch (t) { r = o } }(); var u, h = [], l = !1, f = -1; function c() { l && u && (l = !1, u.length ? h = u.concat(h) : f = -1, h.length && d()) } function d() { if (!l) { var t = s(c); l = !0; for (var e = h.length; e;) { for (u = h, h = []; ++f < e;)u && u[f].run(); f = -1, e = h.length } u = null, l = !1, function (t) { if (r === clearTimeout) return clearTimeout(t); if ((r === o || !r) && clearTimeout) return r = clearTimeout, clearTimeout(t); try { r(t) } catch (e) { try { return r.call(null, t) } catch (e) { return r.call(this, t) } } }(t) } } function p(t, e) { this.fun = t, this.array = e } function g() { } i.nextTick = function (t) { var e = new Array(arguments.length - 1); if (arguments.length > 1) for (var n = 1; n < arguments.length; n++)e[n - 1] = arguments[n]; h.push(new p(t, e)), 1 !== h.length || l || s(d) }, p.prototype.run = function () { this.fun.apply(null, this.array) }, i.title = "browser", i.browser = !0, i.env = {}, i.argv = [], i.version = "", i.versions = {}, i.on = g, i.addListener = g, i.once = g, i.off = g, i.removeListener = g, i.removeAllListeners = g, i.emit = g, i.prependListener = g, i.prependOnceListener = g, i.listeners = function (t) { return [] }, i.binding = function (t) { throw new Error("process.binding is not supported") }, i.cwd = function () { return "/" }, i.chdir = function (t) { throw new Error("process.chdir is not supported") }, i.umask = function () { return 0 } }, function (t, e, n) { "use strict"; (function (e) { void 0 === e || !e.version || 0 === e.version.indexOf("v0.") || 0 === e.version.indexOf("v1.") && 0 !== e.version.indexOf("v1.8.") ? t.exports = { nextTick: function (t, n, r, i) { if ("function" != typeof t) throw new TypeError('"callback" argument must be a function'); var a, o, s = arguments.length; switch (s) { case 0: case 1: return e.nextTick(t); case 2: return e.nextTick((function () { t.call(null, n) })); case 3: return e.nextTick((function () { t.call(null, n, r) })); case 4: return e.nextTick((function () { t.call(null, n, r, i) })); default: for (a = new Array(s - 1), o = 0; o < a.length;)a[o++] = arguments[o]; return e.nextTick((function () { t.apply(null, a) })) } } } : t.exports = e }).call(this, n(6)) }, function (t, e, n) { "use strict"; t.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" } }, function (t, e, n) { "use strict"; var r, i = "object" == typeof Reflect ? Reflect : null, a = i && "function" == typeof i.apply ? i.apply : function (t, e, n) { return Function.prototype.apply.call(t, e, n) }; r = i && "function" == typeof i.ownKeys ? i.ownKeys : Object.getOwnPropertySymbols ? function (t) { return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t)) } : function (t) { return Object.getOwnPropertyNames(t) }; var o = Number.isNaN || function (t) { return t != t }; function s() { s.init.call(this) } t.exports = s, s.EventEmitter = s, s.prototype._events = void 0, s.prototype._eventsCount = 0, s.prototype._maxListeners = void 0; var u = 10; function h(t) { if ("function" != typeof t) throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof t) } function l(t) { return void 0 === t._maxListeners ? s.defaultMaxListeners : t._maxListeners } function f(t, e, n, r) { var i, a, o, s; if (h(n), void 0 === (a = t._events) ? (a = t._events = Object.create(null), t._eventsCount = 0) : (void 0 !== a.newListener && (t.emit("newListener", e, n.listener ? n.listener : n), a = t._events), o = a[e]), void 0 === o) o = a[e] = n, ++t._eventsCount; else if ("function" == typeof o ? o = a[e] = r ? [n, o] : [o, n] : r ? o.unshift(n) : o.push(n), (i = l(t)) > 0 && o.length > i && !o.warned) { o.warned = !0; var u = new Error("Possible EventEmitter memory leak detected. " + o.length + " " + String(e) + " listeners added. Use emitter.setMaxListeners() to increase limit"); u.name = "MaxListenersExceededWarning", u.emitter = t, u.type = e, u.count = o.length, s = u, console && console.warn && console.warn(s) } return t } function c() { if (!this.fired) return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, 0 === arguments.length ? this.listener.call(this.target) : this.listener.apply(this.target, arguments) } function d(t, e, n) { var r = { fired: !1, wrapFn: void 0, target: t, type: e, listener: n }, i = c.bind(r); return i.listener = n, r.wrapFn = i, i } function p(t, e, n) { var r = t._events; if (void 0 === r) return []; var i = r[e]; return void 0 === i ? [] : "function" == typeof i ? n ? [i.listener || i] : [i] : n ? function (t) { for (var e = new Array(t.length), n = 0; n < e.length; ++n)e[n] = t[n].listener || t[n]; return e }(i) : _(i, i.length) } function g(t) { var e = this._events; if (void 0 !== e) { var n = e[t]; if ("function" == typeof n) return 1; if (void 0 !== n) return n.length } return 0 } function _(t, e) { for (var n = new Array(e), r = 0; r < e; ++r)n[r] = t[r]; return n } Object.defineProperty(s, "defaultMaxListeners", { enumerable: !0, get: function () { return u }, set: function (t) { if ("number" != typeof t || t < 0 || o(t)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + t + "."); u = t } }), s.init = function () { void 0 !== this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0 }, s.prototype.setMaxListeners = function (t) { if ("number" != typeof t || t < 0 || o(t)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + t + "."); return this._maxListeners = t, this }, s.prototype.getMaxListeners = function () { return l(this) }, s.prototype.emit = function (t) { for (var e = [], n = 1; n < arguments.length; n++)e.push(arguments[n]); var r = "error" === t, i = this._events; if (void 0 !== i) r = r && void 0 === i.error; else if (!r) return !1; if (r) { var o; if (e.length > 0 && (o = e[0]), o instanceof Error) throw o; var s = new Error("Unhandled error." + (o ? " (" + o.message + ")" : "")); throw s.context = o, s } var u = i[t]; if (void 0 === u) return !1; if ("function" == typeof u) a(u, this, e); else { var h = u.length, l = _(u, h); for (n = 0; n < h; ++n)a(l[n], this, e) } return !0 }, s.prototype.addListener = function (t, e) { return f(this, t, e, !1) }, s.prototype.on = s.prototype.addListener, s.prototype.prependListener = function (t, e) { return f(this, t, e, !0) }, s.prototype.once = function (t, e) { return h(e), this.on(t, d(this, t, e)), this }, s.prototype.prependOnceListener = function (t, e) { return h(e), this.prependListener(t, d(this, t, e)), this }, s.prototype.removeListener = function (t, e) { var n, r, i, a, o; if (h(e), void 0 === (r = this._events)) return this; if (void 0 === (n = r[t])) return this; if (n === e || n.listener === e) 0 == --this._eventsCount ? this._events = Object.create(null) : (delete r[t], r.removeListener && this.emit("removeListener", t, n.listener || e)); else if ("function" != typeof n) { for (i = -1, a = n.length - 1; a >= 0; a--)if (n[a] === e || n[a].listener === e) { o = n[a].listener, i = a; break } if (i < 0) return this; 0 === i ? n.shift() : function (t, e) { for (; e + 1 < t.length; e++)t[e] = t[e + 1]; t.pop() }(n, i), 1 === n.length && (r[t] = n[0]), void 0 !== r.removeListener && this.emit("removeListener", t, o || e) } return this }, s.prototype.off = s.prototype.removeListener, s.prototype.removeAllListeners = function (t) { var e, n, r; if (void 0 === (n = this._events)) return this; if (void 0 === n.removeListener) return 0 === arguments.length ? (this._events = Object.create(null), this._eventsCount = 0) : void 0 !== n[t] && (0 == --this._eventsCount ? this._events = Object.create(null) : delete n[t]), this; if (0 === arguments.length) { var i, a = Object.keys(n); for (r = 0; r < a.length; ++r)"removeListener" !== (i = a[r]) && this.removeAllListeners(i); return this.removeAllListeners("removeListener"), this._events = Object.create(null), this._eventsCount = 0, this } if ("function" == typeof (e = n[t])) this.removeListener(t, e); else if (void 0 !== e) for (r = e.length - 1; r >= 0; r--)this.removeListener(t, e[r]); return this }, s.prototype.listeners = function (t) { return p(this, t, !0) }, s.prototype.rawListeners = function (t) { return p(this, t, !1) }, s.listenerCount = function (t, e) { return "function" == typeof t.listenerCount ? t.listenerCount(e) : g.call(t, e) }, s.prototype.listenerCount = g, s.prototype.eventNames = function () { return this._eventsCount > 0 ? r(this._events) : [] } }, function (t, e, n) { (e = t.exports = n(21)).Stream = e, e.Readable = e, e.Writable = n(12), e.Duplex = n(2), e.Transform = n(24), e.PassThrough = n(48) }, function (t, e, n) { var r = n(4), i = r.Buffer; function a(t, e) { for (var n in t) e[n] = t[n] } function o(t, e, n) { return i(t, e, n) } i.from && i.alloc && i.allocUnsafe && i.allocUnsafeSlow ? t.exports = r : (a(r, e), e.Buffer = o), a(i, o), o.from = function (t, e, n) { if ("number" == typeof t) throw new TypeError("Argument must not be a number"); return i(t, e, n) }, o.alloc = function (t, e, n) { if ("number" != typeof t) throw new TypeError("Argument must be a number"); var r = i(t); return void 0 !== e ? "string" == typeof n ? r.fill(e, n) : r.fill(e) : r.fill(0), r }, o.allocUnsafe = function (t) { if ("number" != typeof t) throw new TypeError("Argument must be a number"); return i(t) }, o.allocUnsafeSlow = function (t) { if ("number" != typeof t) throw new TypeError("Argument must be a number"); return r.SlowBuffer(t) } }, function (t, e, n) { "use strict"; (function (e, r, i) { var a = n(7); function o(t) { var e = this; this.next = null, this.entry = null, this.finish = function () { !function (t, e, n) { var r = t.entry; t.entry = null; for (; r;) { var i = r.callback; e.pendingcb--, i(n), r = r.next } e.corkedRequestsFree ? e.corkedRequestsFree.next = t : e.corkedRequestsFree = t }(e, t) } } t.exports = b; var s, u = !e.browser && ["v0.10", "v0.9."].indexOf(e.version.slice(0, 5)) > -1 ? r : a.nextTick; b.WritableState = m; var h = Object.create(n(5)); h.inherits = n(3); var l = { deprecate: n(46) }, f = n(22), c = n(11).Buffer, d = i.Uint8Array || function () { }; var p, g = n(23); function _() { } function m(t, e) { s = s || n(2), t = t || {}; var r = e instanceof s; this.objectMode = !!t.objectMode, r && (this.objectMode = this.objectMode || !!t.writableObjectMode); var i = t.highWaterMark, h = t.writableHighWaterMark, l = this.objectMode ? 16 : 16384; this.highWaterMark = i || 0 === i ? i : r && (h || 0 === h) ? h : l, this.highWaterMark = Math.floor(this.highWaterMark), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1; var f = !1 === t.decodeStrings; this.decodeStrings = !f, this.defaultEncoding = t.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function (t) { !function (t, e) { var n = t._writableState, r = n.sync, i = n.writecb; if (function (t) { t.writing = !1, t.writecb = null, t.length -= t.writelen, t.writelen = 0 }(n), e) !function (t, e, n, r, i) { --e.pendingcb, n ? (a.nextTick(i, r), a.nextTick(k, t, e), t._writableState.errorEmitted = !0, t.emit("error", r)) : (i(r), t._writableState.errorEmitted = !0, t.emit("error", r), k(t, e)) }(t, n, r, e, i); else { var o = T(n); o || n.corked || n.bufferProcessing || !n.bufferedRequest || y(t, n), r ? u(v, t, n, o, i) : v(t, n, o, i) } }(e, t) }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.bufferedRequestCount = 0, this.corkedRequestsFree = new o(this) } function b(t) { if (s = s || n(2), !(p.call(b, this) || this instanceof s)) return new b(t); this._writableState = new m(t, this), this.writable = !0, t && ("function" == typeof t.write && (this._write = t.write), "function" == typeof t.writev && (this._writev = t.writev), "function" == typeof t.destroy && (this._destroy = t.destroy), "function" == typeof t.final && (this._final = t.final)), f.call(this) } function w(t, e, n, r, i, a, o) { e.writelen = r, e.writecb = o, e.writing = !0, e.sync = !0, n ? t._writev(i, e.onwrite) : t._write(i, a, e.onwrite), e.sync = !1 } function v(t, e, n, r) { n || function (t, e) { 0 === e.length && e.needDrain && (e.needDrain = !1, t.emit("drain")) }(t, e), e.pendingcb--, r(), k(t, e) } function y(t, e) { e.bufferProcessing = !0; var n = e.bufferedRequest; if (t._writev && n && n.next) { var r = e.bufferedRequestCount, i = new Array(r), a = e.corkedRequestsFree; a.entry = n; for (var s = 0, u = !0; n;)i[s] = n, n.isBuf || (u = !1), n = n.next, s += 1; i.allBuffers = u, w(t, e, !0, e.length, i, "", a.finish), e.pendingcb++, e.lastBufferedRequest = null, a.next ? (e.corkedRequestsFree = a.next, a.next = null) : e.corkedRequestsFree = new o(e), e.bufferedRequestCount = 0 } else { for (; n;) { var h = n.chunk, l = n.encoding, f = n.callback; if (w(t, e, !1, e.objectMode ? 1 : h.length, h, l, f), n = n.next, e.bufferedRequestCount--, e.writing) break } null === n && (e.lastBufferedRequest = null) } e.bufferedRequest = n, e.bufferProcessing = !1 } function T(t) { return t.ending && 0 === t.length && null === t.bufferedRequest && !t.finished && !t.writing } function E(t, e) { t._final((function (n) { e.pendingcb--, n && t.emit("error", n), e.prefinished = !0, t.emit("prefinish"), k(t, e) })) } function k(t, e) { var n = T(e); return n && (!function (t, e) { e.prefinished || e.finalCalled || ("function" == typeof t._final ? (e.pendingcb++, e.finalCalled = !0, a.nextTick(E, t, e)) : (e.prefinished = !0, t.emit("prefinish"))) }(t, e), 0 === e.pendingcb && (e.finished = !0, t.emit("finish"))), n } h.inherits(b, f), m.prototype.getBuffer = function () { for (var t = this.bufferedRequest, e = []; t;)e.push(t), t = t.next; return e }, function () { try { Object.defineProperty(m.prototype, "buffer", { get: l.deprecate((function () { return this.getBuffer() }), "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003") }) } catch (t) { } }(), "function" == typeof Symbol && Symbol.hasInstance && "function" == typeof Function.prototype[Symbol.hasInstance] ? (p = Function.prototype[Symbol.hasInstance], Object.defineProperty(b, Symbol.hasInstance, { value: function (t) { return !!p.call(this, t) || this === b && (t && t._writableState instanceof m) } })) : p = function (t) { return t instanceof this }, b.prototype.pipe = function () { this.emit("error", new Error("Cannot pipe, not readable")) }, b.prototype.write = function (t, e, n) { var r, i = this._writableState, o = !1, s = !i.objectMode && (r = t, c.isBuffer(r) || r instanceof d); return s && !c.isBuffer(t) && (t = function (t) { return c.from(t) }(t)), "function" == typeof e && (n = e, e = null), s ? e = "buffer" : e || (e = i.defaultEncoding), "function" != typeof n && (n = _), i.ended ? function (t, e) { var n = new Error("write after end"); t.emit("error", n), a.nextTick(e, n) }(this, n) : (s || function (t, e, n, r) { var i = !0, o = !1; return null === n ? o = new TypeError("May not write null values to stream") : "string" == typeof n || void 0 === n || e.objectMode || (o = new TypeError("Invalid non-string/buffer chunk")), o && (t.emit("error", o), a.nextTick(r, o), i = !1), i }(this, i, t, n)) && (i.pendingcb++, o = function (t, e, n, r, i, a) { if (!n) { var o = function (t, e, n) { t.objectMode || !1 === t.decodeStrings || "string" != typeof e || (e = c.from(e, n)); return e }(e, r, i); r !== o && (n = !0, i = "buffer", r = o) } var s = e.objectMode ? 1 : r.length; e.length += s; var u = e.length < e.highWaterMark; u || (e.needDrain = !0); if (e.writing || e.corked) { var h = e.lastBufferedRequest; e.lastBufferedRequest = { chunk: r, encoding: i, isBuf: n, callback: a, next: null }, h ? h.next = e.lastBufferedRequest : e.bufferedRequest = e.lastBufferedRequest, e.bufferedRequestCount += 1 } else w(t, e, !1, s, r, i, a); return u }(this, i, s, t, e, n)), o }, b.prototype.cork = function () { this._writableState.corked++ }, b.prototype.uncork = function () { var t = this._writableState; t.corked && (t.corked--, t.writing || t.corked || t.finished || t.bufferProcessing || !t.bufferedRequest || y(this, t)) }, b.prototype.setDefaultEncoding = function (t) { if ("string" == typeof t && (t = t.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((t + "").toLowerCase()) > -1)) throw new TypeError("Unknown encoding: " + t); return this._writableState.defaultEncoding = t, this }, Object.defineProperty(b.prototype, "writableHighWaterMark", { enumerable: !1, get: function () { return this._writableState.highWaterMark } }), b.prototype._write = function (t, e, n) { n(new Error("_write() is not implemented")) }, b.prototype._writev = null, b.prototype.end = function (t, e, n) { var r = this._writableState; "function" == typeof t ? (n = t, t = null, e = null) : "function" == typeof e && (n = e, e = null), null != t && this.write(t, e), r.corked && (r.corked = 1, this.uncork()), r.ending || r.finished || function (t, e, n) { e.ending = !0, k(t, e), n && (e.finished ? a.nextTick(n) : t.once("finish", n)); e.ended = !0, t.writable = !1 }(this, r, n) }, Object.defineProperty(b.prototype, "destroyed", { get: function () { return void 0 !== this._writableState && this._writableState.destroyed }, set: function (t) { this._writableState && (this._writableState.destroyed = t) } }), b.prototype.destroy = g.destroy, b.prototype._undestroy = g.undestroy, b.prototype._destroy = function (t, e) { this.end(), e(t) } }).call(this, n(6), n(44).setImmediate, n(1)) }, function (t, e, n) { "use strict"; var r = n(47).Buffer, i = r.isEncoding || function (t) { switch ((t = "" + t) && t.toLowerCase()) { case "hex": case "utf8": case "utf-8": case "ascii": case "binary": case "base64": case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": case "raw": return !0; default: return !1 } }; function a(t) { var e; switch (this.encoding = function (t) { var e = function (t) { if (!t) return "utf8"; for (var e; ;)switch (t) { case "utf8": case "utf-8": return "utf8"; case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return "utf16le"; case "latin1": case "binary": return "latin1"; case "base64": case "ascii": case "hex": return t; default: if (e) return; t = ("" + t).toLowerCase(), e = !0 } }(t); if ("string" != typeof e && (r.isEncoding === i || !i(t))) throw new Error("Unknown encoding: " + t); return e || t }(t), this.encoding) { case "utf16le": this.text = u, this.end = h, e = 4; break; case "utf8": this.fillLast = s, e = 4; break; case "base64": this.text = l, this.end = f, e = 3; break; default: return this.write = c, void (this.end = d) }this.lastNeed = 0, this.lastTotal = 0, this.lastChar = r.allocUnsafe(e) } function o(t) { return t <= 127 ? 0 : t >> 5 == 6 ? 2 : t >> 4 == 14 ? 3 : t >> 3 == 30 ? 4 : t >> 6 == 2 ? -1 : -2 } function s(t) { var e = this.lastTotal - this.lastNeed, n = function (t, e, n) { if (128 != (192 & e[0])) return t.lastNeed = 0, ""; if (t.lastNeed > 1 && e.length > 1) { if (128 != (192 & e[1])) return t.lastNeed = 1, ""; if (t.lastNeed > 2 && e.length > 2 && 128 != (192 & e[2])) return t.lastNeed = 2, "" } }(this, t); return void 0 !== n ? n : this.lastNeed <= t.length ? (t.copy(this.lastChar, e, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal)) : (t.copy(this.lastChar, e, 0, t.length), void (this.lastNeed -= t.length)) } function u(t, e) { if ((t.length - e) % 2 == 0) { var n = t.toString("utf16le", e); if (n) { var r = n.charCodeAt(n.length - 1); if (r >= 55296 && r <= 56319) return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = t[t.length - 2], this.lastChar[1] = t[t.length - 1], n.slice(0, -1) } return n } return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = t[t.length - 1], t.toString("utf16le", e, t.length - 1) } function h(t) { var e = t && t.length ? this.write(t) : ""; if (this.lastNeed) { var n = this.lastTotal - this.lastNeed; return e + this.lastChar.toString("utf16le", 0, n) } return e } function l(t, e) { var n = (t.length - e) % 3; return 0 === n ? t.toString("base64", e) : (this.lastNeed = 3 - n, this.lastTotal = 3, 1 === n ? this.lastChar[0] = t[t.length - 1] : (this.lastChar[0] = t[t.length - 2], this.lastChar[1] = t[t.length - 1]), t.toString("base64", e, t.length - n)) } function f(t) { var e = t && t.length ? this.write(t) : ""; return this.lastNeed ? e + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : e } function c(t) { return t.toString(this.encoding) } function d(t) { return t && t.length ? this.write(t) : "" } e.StringDecoder = a, a.prototype.write = function (t) { if (0 === t.length) return ""; var e, n; if (this.lastNeed) { if (void 0 === (e = this.fillLast(t))) return ""; n = this.lastNeed, this.lastNeed = 0 } else n = 0; return n < t.length ? e ? e + this.text(t, n) : this.text(t, n) : e || "" }, a.prototype.end = function (t) { var e = t && t.length ? this.write(t) : ""; return this.lastNeed ? e + "" : e }, a.prototype.text = function (t, e) { var n = function (t, e, n) { var r = e.length - 1; if (r < n) return 0; var i = o(e[r]); if (i >= 0) return i > 0 && (t.lastNeed = i - 1), i; if (--r < n || -2 === i) return 0; if ((i = o(e[r])) >= 0) return i > 0 && (t.lastNeed = i - 2), i; if (--r < n || -2 === i) return 0; if ((i = o(e[r])) >= 0) return i > 0 && (2 === i ? i = 0 : t.lastNeed = i - 3), i; return 0 }(this, t, e); if (!this.lastNeed) return t.toString("utf8", e); this.lastTotal = n; var r = t.length - (n - this.lastNeed); return t.copy(this.lastChar, 0, r), t.toString("utf8", e, r) }, a.prototype.fillLast = function (t) { if (this.lastNeed <= t.length) return t.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal); t.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, t.length), this.lastNeed -= t.length } }, function (t, e) { var n = {}.toString; t.exports = Array.isArray || function (t) { return "[object Array]" == n.call(t) } }, function (t, e, n) { "use strict"; t.exports = function (t, e, n, r) { for (var i = 65535 & t | 0, a = t >>> 16 & 65535 | 0, o = 0; 0 !== n;) { n -= o = n > 2e3 ? 2e3 : n; do { a = a + (i = i + e[r++] | 0) | 0 } while (--o); i %= 65521, a %= 65521 } return i | a << 16 | 0 } }, function (t, e, n) { "use strict"; var r = function () { for (var t, e = [], n = 0; n < 256; n++) { t = n; for (var r = 0; r < 8; r++)t = 1 & t ? 3988292384 ^ t >>> 1 : t >>> 1; e[n] = t } return e }(); t.exports = function (t, e, n, i) { var a = r, o = i + n; t ^= -1; for (var s = i; s < o; s++)t = t >>> 8 ^ a[255 & (t ^ e[s])]; return -1 ^ t } }, function (t, e, n) { "use strict"; var r = n(0), i = !0, a = !0; try { String.fromCharCode.apply(null, [0]) } catch (t) { i = !1 } try { String.fromCharCode.apply(null, new Uint8Array(1)) } catch (t) { a = !1 } for (var o = new r.Buf8(256), s = 0; s < 256; s++)o[s] = s >= 252 ? 6 : s >= 248 ? 5 : s >= 240 ? 4 : s >= 224 ? 3 : s >= 192 ? 2 : 1; function u(t, e) { if (e < 65534 && (t.subarray && a || !t.subarray && i)) return String.fromCharCode.apply(null, r.shrinkBuf(t, e)); for (var n = "", o = 0; o < e; o++)n += String.fromCharCode(t[o]); return n } o[254] = o[254] = 1, e.string2buf = function (t) { var e, n, i, a, o, s = t.length, u = 0; for (a = 0; a < s; a++)55296 == (64512 & (n = t.charCodeAt(a))) && a + 1 < s && 56320 == (64512 & (i = t.charCodeAt(a + 1))) && (n = 65536 + (n - 55296 << 10) + (i - 56320), a++), u += n < 128 ? 1 : n < 2048 ? 2 : n < 65536 ? 3 : 4; for (e = new r.Buf8(u), o = 0, a = 0; o < u; a++)55296 == (64512 & (n = t.charCodeAt(a))) && a + 1 < s && 56320 == (64512 & (i = t.charCodeAt(a + 1))) && (n = 65536 + (n - 55296 << 10) + (i - 56320), a++), n < 128 ? e[o++] = n : n < 2048 ? (e[o++] = 192 | n >>> 6, e[o++] = 128 | 63 & n) : n < 65536 ? (e[o++] = 224 | n >>> 12, e[o++] = 128 | n >>> 6 & 63, e[o++] = 128 | 63 & n) : (e[o++] = 240 | n >>> 18, e[o++] = 128 | n >>> 12 & 63, e[o++] = 128 | n >>> 6 & 63, e[o++] = 128 | 63 & n); return e }, e.buf2binstring = function (t) { return u(t, t.length) }, e.binstring2buf = function (t) { for (var e = new r.Buf8(t.length), n = 0, i = e.length; n < i; n++)e[n] = t.charCodeAt(n); return e }, e.buf2string = function (t, e) { var n, r, i, a, s = e || t.length, h = new Array(2 * s); for (r = 0, n = 0; n < s;)if ((i = t[n++]) < 128) h[r++] = i; else if ((a = o[i]) > 4) h[r++] = 65533, n += a - 1; else { for (i &= 2 === a ? 31 : 3 === a ? 15 : 7; a > 1 && n < s;)i = i << 6 | 63 & t[n++], a--; a > 1 ? h[r++] = 65533 : i < 65536 ? h[r++] = i : (i -= 65536, h[r++] = 55296 | i >> 10 & 1023, h[r++] = 56320 | 1023 & i) } return u(h, r) }, e.utf8border = function (t, e) { var n; for ((e = e || t.length) > t.length && (e = t.length), n = e - 1; n >= 0 && 128 == (192 & t[n]);)n--; return n < 0 ? e : 0 === n ? e : n + o[t[n]] > e ? n : e } }, function (t, e, n) { "use strict"; t.exports = function () { this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0 } }, function (t, e, n) { "use strict"; t.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 } }, function (t, e, n) { t.exports = n(38) }, function (t, e, n) { "use strict"; (function (e, r) { var i = n(7); t.exports = w; var a, o = n(14); w.ReadableState = b; n(9).EventEmitter; var s = function (t, e) { return t.listeners(e).length }, u = n(22), h = n(11).Buffer, l = e.Uint8Array || function () { }; var f = Object.create(n(5)); f.inherits = n(3); var c = n(41), d = void 0; d = c && c.debuglog ? c.debuglog("stream") : function () { }; var p, g = n(42), _ = n(23); f.inherits(w, u); var m = ["error", "close", "destroy", "pause", "resume"]; function b(t, e) { t = t || {}; var r = e instanceof (a = a || n(2)); this.objectMode = !!t.objectMode, r && (this.objectMode = this.objectMode || !!t.readableObjectMode); var i = t.highWaterMark, o = t.readableHighWaterMark, s = this.objectMode ? 16 : 16384; this.highWaterMark = i || 0 === i ? i : r && (o || 0 === o) ? o : s, this.highWaterMark = Math.floor(this.highWaterMark), this.buffer = new g, this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.destroyed = !1, this.defaultEncoding = t.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, t.encoding && (p || (p = n(13).StringDecoder), this.decoder = new p(t.encoding), this.encoding = t.encoding) } function w(t) { if (a = a || n(2), !(this instanceof w)) return new w(t); this._readableState = new b(t, this), this.readable = !0, t && ("function" == typeof t.read && (this._read = t.read), "function" == typeof t.destroy && (this._destroy = t.destroy)), u.call(this) } function v(t, e, n, r, i) { var a, o = t._readableState; null === e ? (o.reading = !1, function (t, e) { if (e.ended) return; if (e.decoder) { var n = e.decoder.end(); n && n.length && (e.buffer.push(n), e.length += e.objectMode ? 1 : n.length) } e.ended = !0, E(t) }(t, o)) : (i || (a = function (t, e) { var n; r = e, h.isBuffer(r) || r instanceof l || "string" == typeof e || void 0 === e || t.objectMode || (n = new TypeError("Invalid non-string/buffer chunk")); var r; return n }(o, e)), a ? t.emit("error", a) : o.objectMode || e && e.length > 0 ? ("string" == typeof e || o.objectMode || Object.getPrototypeOf(e) === h.prototype || (e = function (t) { return h.from(t) }(e)), r ? o.endEmitted ? t.emit("error", new Error("stream.unshift() after end event")) : y(t, o, e, !0) : o.ended ? t.emit("error", new Error("stream.push() after EOF")) : (o.reading = !1, o.decoder && !n ? (e = o.decoder.write(e), o.objectMode || 0 !== e.length ? y(t, o, e, !1) : x(t, o)) : y(t, o, e, !1))) : r || (o.reading = !1)); return function (t) { return !t.ended && (t.needReadable || t.length < t.highWaterMark || 0 === t.length) }(o) } function y(t, e, n, r) { e.flowing && 0 === e.length && !e.sync ? (t.emit("data", n), t.read(0)) : (e.length += e.objectMode ? 1 : n.length, r ? e.buffer.unshift(n) : e.buffer.push(n), e.needReadable && E(t)), x(t, e) } Object.defineProperty(w.prototype, "destroyed", { get: function () { return void 0 !== this._readableState && this._readableState.destroyed }, set: function (t) { this._readableState && (this._readableState.destroyed = t) } }), w.prototype.destroy = _.destroy, w.prototype._undestroy = _.undestroy, w.prototype._destroy = function (t, e) { this.push(null), e(t) }, w.prototype.push = function (t, e) { var n, r = this._readableState; return r.objectMode ? n = !0 : "string" == typeof t && ((e = e || r.defaultEncoding) !== r.encoding && (t = h.from(t, e), e = ""), n = !0), v(this, t, e, !1, n) }, w.prototype.unshift = function (t) { return v(this, t, null, !0, !1) }, w.prototype.isPaused = function () { return !1 === this._readableState.flowing }, w.prototype.setEncoding = function (t) { return p || (p = n(13).StringDecoder), this._readableState.decoder = new p(t), this._readableState.encoding = t, this }; function T(t, e) { return t <= 0 || 0 === e.length && e.ended ? 0 : e.objectMode ? 1 : t != t ? e.flowing && e.length ? e.buffer.head.data.length : e.length : (t > e.highWaterMark && (e.highWaterMark = function (t) { return t >= 8388608 ? t = 8388608 : (t--, t |= t >>> 1, t |= t >>> 2, t |= t >>> 4, t |= t >>> 8, t |= t >>> 16, t++), t }(t)), t <= e.length ? t : e.ended ? e.length : (e.needReadable = !0, 0)) } function E(t) { var e = t._readableState; e.needReadable = !1, e.emittedReadable || (d("emitReadable", e.flowing), e.emittedReadable = !0, e.sync ? i.nextTick(k, t) : k(t)) } function k(t) { d("emit readable"), t.emit("readable"), C(t) } function x(t, e) { e.readingMore || (e.readingMore = !0, i.nextTick(S, t, e)) } function S(t, e) { for (var n = e.length; !e.reading && !e.flowing && !e.ended && e.length < e.highWaterMark && (d("maybeReadMore read 0"), t.read(0), n !== e.length);)n = e.length; e.readingMore = !1 } function A(t) { d("readable nexttick read 0"), t.read(0) } function N(t, e) { e.reading || (d("resume read 0"), t.read(0)), e.resumeScheduled = !1, e.awaitDrain = 0, t.emit("resume"), C(t), e.flowing && !e.reading && t.read(0) } function C(t) { var e = t._readableState; for (d("flow", e.flowing); e.flowing && null !== t.read();); } function I(t, e) { return 0 === e.length ? null : (e.objectMode ? n = e.buffer.shift() : !t || t >= e.length ? (n = e.decoder ? e.buffer.join("") : 1 === e.buffer.length ? e.buffer.head.data : e.buffer.concat(e.length), e.buffer.clear()) : n = function (t, e, n) { var r; t < e.head.data.length ? (r = e.head.data.slice(0, t), e.head.data = e.head.data.slice(t)) : r = t === e.head.data.length ? e.shift() : n ? function (t, e) { var n = e.head, r = 1, i = n.data; t -= i.length; for (; n = n.next;) { var a = n.data, o = t > a.length ? a.length : t; if (o === a.length ? i += a : i += a.slice(0, t), 0 === (t -= o)) { o === a.length ? (++r, n.next ? e.head = n.next : e.head = e.tail = null) : (e.head = n, n.data = a.slice(o)); break } ++r } return e.length -= r, i }(t, e) : function (t, e) { var n = h.allocUnsafe(t), r = e.head, i = 1; r.data.copy(n), t -= r.data.length; for (; r = r.next;) { var a = r.data, o = t > a.length ? a.length : t; if (a.copy(n, n.length - t, 0, o), 0 === (t -= o)) { o === a.length ? (++i, r.next ? e.head = r.next : e.head = e.tail = null) : (e.head = r, r.data = a.slice(o)); break } ++i } return e.length -= i, n }(t, e); return r }(t, e.buffer, e.decoder), n); var n } function R(t) { var e = t._readableState; if (e.length > 0) throw new Error('"endReadable()" called on non-empty stream'); e.endEmitted || (e.ended = !0, i.nextTick(O, e, t)) } function O(t, e) { t.endEmitted || 0 !== t.length || (t.endEmitted = !0, e.readable = !1, e.emit("end")) } function D(t, e) { for (var n = 0, r = t.length; n < r; n++)if (t[n] === e) return n; return -1 } w.prototype.read = function (t) { d("read", t), t = parseInt(t, 10); var e = this._readableState, n = t; if (0 !== t && (e.emittedReadable = !1), 0 === t && e.needReadable && (e.length >= e.highWaterMark || e.ended)) return d("read: emitReadable", e.length, e.ended), 0 === e.length && e.ended ? R(this) : E(this), null; if (0 === (t = T(t, e)) && e.ended) return 0 === e.length && R(this), null; var r, i = e.needReadable; return d("need readable", i), (0 === e.length || e.length - t < e.highWaterMark) && d("length less than watermark", i = !0), e.ended || e.reading ? d("reading or ended", i = !1) : i && (d("do read"), e.reading = !0, e.sync = !0, 0 === e.length && (e.needReadable = !0), this._read(e.highWaterMark), e.sync = !1, e.reading || (t = T(n, e))), null === (r = t > 0 ? I(t, e) : null) ? (e.needReadable = !0, t = 0) : e.length -= t, 0 === e.length && (e.ended || (e.needReadable = !0), n !== t && e.ended && R(this)), null !== r && this.emit("data", r), r }, w.prototype._read = function (t) { this.emit("error", new Error("_read() is not implemented")) }, w.prototype.pipe = function (t, e) { var n = this, a = this._readableState; switch (a.pipesCount) { case 0: a.pipes = t; break; case 1: a.pipes = [a.pipes, t]; break; default: a.pipes.push(t) }a.pipesCount += 1, d("pipe count=%d opts=%j", a.pipesCount, e); var u = (!e || !1 !== e.end) && t !== r.stdout && t !== r.stderr ? l : w; function h(e, r) { d("onunpipe"), e === n && r && !1 === r.hasUnpiped && (r.hasUnpiped = !0, d("cleanup"), t.removeListener("close", m), t.removeListener("finish", b), t.removeListener("drain", f), t.removeListener("error", _), t.removeListener("unpipe", h), n.removeListener("end", l), n.removeListener("end", w), n.removeListener("data", g), c = !0, !a.awaitDrain || t._writableState && !t._writableState.needDrain || f()) } function l() { d("onend"), t.end() } a.endEmitted ? i.nextTick(u) : n.once("end", u), t.on("unpipe", h); var f = function (t) { return function () { var e = t._readableState; d("pipeOnDrain", e.awaitDrain), e.awaitDrain && e.awaitDrain--, 0 === e.awaitDrain && s(t, "data") && (e.flowing = !0, C(t)) } }(n); t.on("drain", f); var c = !1; var p = !1; function g(e) { d("ondata"), p = !1, !1 !== t.write(e) || p || ((1 === a.pipesCount && a.pipes === t || a.pipesCount > 1 && -1 !== D(a.pipes, t)) && !c && (d("false write response, pause", n._readableState.awaitDrain), n._readableState.awaitDrain++, p = !0), n.pause()) } function _(e) { d("onerror", e), w(), t.removeListener("error", _), 0 === s(t, "error") && t.emit("error", e) } function m() { t.removeListener("finish", b), w() } function b() { d("onfinish"), t.removeListener("close", m), w() } function w() { d("unpipe"), n.unpipe(t) } return n.on("data", g), function (t, e, n) { if ("function" == typeof t.prependListener) return t.prependListener(e, n); t._events && t._events[e] ? o(t._events[e]) ? t._events[e].unshift(n) : t._events[e] = [n, t._events[e]] : t.on(e, n) }(t, "error", _), t.once("close", m), t.once("finish", b), t.emit("pipe", n), a.flowing || (d("pipe resume"), n.resume()), t }, w.prototype.unpipe = function (t) { var e = this._readableState, n = { hasUnpiped: !1 }; if (0 === e.pipesCount) return this; if (1 === e.pipesCount) return t && t !== e.pipes ? this : (t || (t = e.pipes), e.pipes = null, e.pipesCount = 0, e.flowing = !1, t && t.emit("unpipe", this, n), this); if (!t) { var r = e.pipes, i = e.pipesCount; e.pipes = null, e.pipesCount = 0, e.flowing = !1; for (var a = 0; a < i; a++)r[a].emit("unpipe", this, n); return this } var o = D(e.pipes, t); return -1 === o ? this : (e.pipes.splice(o, 1), e.pipesCount -= 1, 1 === e.pipesCount && (e.pipes = e.pipes[0]), t.emit("unpipe", this, n), this) }, w.prototype.on = function (t, e) { var n = u.prototype.on.call(this, t, e); if ("data" === t) !1 !== this._readableState.flowing && this.resume(); else if ("readable" === t) { var r = this._readableState; r.endEmitted || r.readableListening || (r.readableListening = r.needReadable = !0, r.emittedReadable = !1, r.reading ? r.length && E(this) : i.nextTick(A, this)) } return n }, w.prototype.addListener = w.prototype.on, w.prototype.resume = function () { var t = this._readableState; return t.flowing || (d("resume"), t.flowing = !0, function (t, e) { e.resumeScheduled || (e.resumeScheduled = !0, i.nextTick(N, t, e)) }(this, t)), this }, w.prototype.pause = function () { return d("call pause flowing=%j", this._readableState.flowing), !1 !== this._readableState.flowing && (d("pause"), this._readableState.flowing = !1, this.emit("pause")), this }, w.prototype.wrap = function (t) { var e = this, n = this._readableState, r = !1; for (var i in t.on("end", (function () { if (d("wrapped end"), n.decoder && !n.ended) { var t = n.decoder.end(); t && t.length && e.push(t) } e.push(null) })), t.on("data", (function (i) { (d("wrapped data"), n.decoder && (i = n.decoder.write(i)), n.objectMode && null == i) || (n.objectMode || i && i.length) && (e.push(i) || (r = !0, t.pause())) })), t) void 0 === this[i] && "function" == typeof t[i] && (this[i] = function (e) { return function () { return t[e].apply(t, arguments) } }(i)); for (var a = 0; a < m.length; a++)t.on(m[a], this.emit.bind(this, m[a])); return this._read = function (e) { d("wrapped _read", e), r && (r = !1, t.resume()) }, this }, Object.defineProperty(w.prototype, "readableHighWaterMark", { enumerable: !1, get: function () { return this._readableState.highWaterMark } }), w._fromList = I }).call(this, n(1), n(6)) }, function (t, e, n) { t.exports = n(9).EventEmitter }, function (t, e, n) { "use strict"; var r = n(7); function i(t, e) { t.emit("error", e) } t.exports = { destroy: function (t, e) { var n = this, a = this._readableState && this._readableState.destroyed, o = this._writableState && this._writableState.destroyed; return a || o ? (e ? e(t) : !t || this._writableState && this._writableState.errorEmitted || r.nextTick(i, this, t), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(t || null, (function (t) { !e && t ? (r.nextTick(i, n, t), n._writableState && (n._writableState.errorEmitted = !0)) : e && e(t) })), this) }, undestroy: function () { this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1) } } }, function (t, e, n) { "use strict"; t.exports = o; var r = n(2), i = Object.create(n(5)); function a(t, e) { var n = this._transformState; n.transforming = !1; var r = n.writecb; if (!r) return this.emit("error", new Error("write callback called multiple times")); n.writechunk = null, n.writecb = null, null != e && this.push(e), r(t); var i = this._readableState; i.reading = !1, (i.needReadable || i.length < i.highWaterMark) && this._read(i.highWaterMark) } function o(t) { if (!(this instanceof o)) return new o(t); r.call(this, t), this._transformState = { afterTransform: a.bind(this), needTransform: !1, transforming: !1, writecb: null, writechunk: null, writeencoding: null }, this._readableState.needReadable = !0, this._readableState.sync = !1, t && ("function" == typeof t.transform && (this._transform = t.transform), "function" == typeof t.flush && (this._flush = t.flush)), this.on("prefinish", s) } function s() { var t = this; "function" == typeof this._flush ? this._flush((function (e, n) { u(t, e, n) })) : u(this, null, null) } function u(t, e, n) { if (e) return t.emit("error", e); if (null != n && t.push(n), t._writableState.length) throw new Error("Calling transform done when ws.length != 0"); if (t._transformState.transforming) throw new Error("Calling transform done when still transforming"); return t.push(null) } i.inherits = n(3), i.inherits(o, r), o.prototype.push = function (t, e) { return this._transformState.needTransform = !1, r.prototype.push.call(this, t, e) }, o.prototype._transform = function (t, e, n) { throw new Error("_transform() is not implemented") }, o.prototype._write = function (t, e, n) { var r = this._transformState; if (r.writecb = n, r.writechunk = t, r.writeencoding = e, !r.transforming) { var i = this._readableState; (r.needTransform || i.needReadable || i.length < i.highWaterMark) && this._read(i.highWaterMark) } }, o.prototype._read = function (t) { var e = this._transformState; null !== e.writechunk && e.writecb && !e.transforming ? (e.transforming = !0, this._transform(e.writechunk, e.writeencoding, e.afterTransform)) : e.needTransform = !0 }, o.prototype._destroy = function (t, e) { var n = this; r.prototype._destroy.call(this, t, (function (t) { e(t), n.emit("close") })) } }, function (t, e, n) { "use strict"; var r = n(26), i = o(n(20)), a = o(n(53)); function o(t) { return t && t.__esModule ? t : { default: t } } var s = function () { return function (t, e, n, a) { var o = t[e]; o.info.trim(); return function (t, e, n) { var a = t.trim(); if (!a) return ""; try { (0, r.validateDrawioData)(a) } catch (t) { return '\n<div class="drawio-viewer-index-' + e + ' markdownItDrawioViewer markdownItDrawioViewerError">\n  <p>MarkdownItDrawioViewer Error: ' + t + "</p>\n</div>\n" } var o = null; try { new i.default.XmlDocument(a).valueWithPath("diagram") && (o = a) } catch (t) { o = '\n<mxfile version="6.8.9" editor="www.draw.io" type="atlas">\n  <mxAtlasLibraries/>\n  <diagram>' + a + "</diagram>\n</mxfile>\n" } var s, u = { editable: !1, highlight: "#0000ff", nav: !1, toolbar: null, edit: null, resize: !0, lightbox: "false", xml: o }, h = JSON.stringify(u); return '\n<div class="drawio-viewer-index-' + e + ' markdownItDrawioViewer"\n  data-begin-line-number-of-markdown="' + n.beginLineNumber + '"\n  data-end-line-number-of-markdown="' + n.endLineNumber + '">\n  <div class="mxgraph" style="max-width: 100%; border: 1px solid transparent" data-mxgraph="' + ("string" != typeof (s = h) ? s : s.replace(/[&'`"<>]/g, (function (t) { return { "&": "&amp;", "'": "&#x27;", "`": "&#x60;", '"': "&quot;", "<": "&lt;", ">": "&gt;" }[t] }))) + '"></div>\n</div>\n' }(o.content.trim(), e, { beginLineNumber: o.map[0], endLineNumber: o.map[1] }) } }; t.exports = function (t, e) { (e = e || {}).render || t.renderer.rules.image; var n = e.marker || "`"; return (0, a.default)(t, "drawio", { marker: n, render: s() }) } }, function (t, e, n) { "use strict"; (function (t) { Object.defineProperty(e, "__esModule", { value: !0 }), e.validateDrawioData = e.getTextContent = void 0; var r = a(n(29)), i = a(n(20)); function a(t) { return t && t.__esModule ? t : { default: t } } e.getTextContent = function (t) { return null != t ? t[void 0 === t.textContent ? "text" : "textContent"] : "" }, e.validateDrawioData = function (e) { try { e = new i.default.XmlDocument(e).valueWithPath("diagram") } catch (t) { } try { e = "undefined" == typeof window ? new t(e, "base64").toString("binary") : atob(e) } catch (t) { throw "atob failed: " + t } if (e.length > 0) try { e = function (t) { for (var e = "", n = 0; n < t.length; n++)e += String.fromCharCode(t[n]); return e }(r.default.inflateRaw(e)) } catch (t) { throw "inflateRaw failed: " + t } try { e = decodeURIComponent(e) } catch (t) { throw "decodeURIComponent failed: " + t } return !0 } }).call(this, n(4).Buffer) }, function (t, e, n) { "use strict"; e.byteLength = function (t) { var e = h(t), n = e[0], r = e[1]; return 3 * (n + r) / 4 - r }, e.toByteArray = function (t) { var e, n, r = h(t), o = r[0], s = r[1], u = new a(function (t, e, n) { return 3 * (e + n) / 4 - n }(0, o, s)), l = 0, f = s > 0 ? o - 4 : o; for (n = 0; n < f; n += 4)e = i[t.charCodeAt(n)] << 18 | i[t.charCodeAt(n + 1)] << 12 | i[t.charCodeAt(n + 2)] << 6 | i[t.charCodeAt(n + 3)], u[l++] = e >> 16 & 255, u[l++] = e >> 8 & 255, u[l++] = 255 & e; 2 === s && (e = i[t.charCodeAt(n)] << 2 | i[t.charCodeAt(n + 1)] >> 4, u[l++] = 255 & e); 1 === s && (e = i[t.charCodeAt(n)] << 10 | i[t.charCodeAt(n + 1)] << 4 | i[t.charCodeAt(n + 2)] >> 2, u[l++] = e >> 8 & 255, u[l++] = 255 & e); return u }, e.fromByteArray = function (t) { for (var e, n = t.length, i = n % 3, a = [], o = 0, s = n - i; o < s; o += 16383)a.push(l(t, o, o + 16383 > s ? s : o + 16383)); 1 === i ? (e = t[n - 1], a.push(r[e >> 2] + r[e << 4 & 63] + "==")) : 2 === i && (e = (t[n - 2] << 8) + t[n - 1], a.push(r[e >> 10] + r[e >> 4 & 63] + r[e << 2 & 63] + "=")); return a.join("") }; for (var r = [], i = [], a = "undefined" != typeof Uint8Array ? Uint8Array : Array, o = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", s = 0, u = o.length; s < u; ++s)r[s] = o[s], i[o.charCodeAt(s)] = s; function h(t) { var e = t.length; if (e % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4"); var n = t.indexOf("="); return -1 === n && (n = e), [n, n === e ? 0 : 4 - n % 4] } function l(t, e, n) { for (var i, a, o = [], s = e; s < n; s += 3)i = (t[s] << 16 & 16711680) + (t[s + 1] << 8 & 65280) + (255 & t[s + 2]), o.push(r[(a = i) >> 18 & 63] + r[a >> 12 & 63] + r[a >> 6 & 63] + r[63 & a]); return o.join("") } i["-".charCodeAt(0)] = 62, i["_".charCodeAt(0)] = 63 }, function (t, e) { e.read = function (t, e, n, r, i) { var a, o, s = 8 * i - r - 1, u = (1 << s) - 1, h = u >> 1, l = -7, f = n ? i - 1 : 0, c = n ? -1 : 1, d = t[e + f]; for (f += c, a = d & (1 << -l) - 1, d >>= -l, l += s; l > 0; a = 256 * a + t[e + f], f += c, l -= 8); for (o = a & (1 << -l) - 1, a >>= -l, l += r; l > 0; o = 256 * o + t[e + f], f += c, l -= 8); if (0 === a) a = 1 - h; else { if (a === u) return o ? NaN : 1 / 0 * (d ? -1 : 1); o += Math.pow(2, r), a -= h } return (d ? -1 : 1) * o * Math.pow(2, a - r) }, e.write = function (t, e, n, r, i, a) { var o, s, u, h = 8 * a - i - 1, l = (1 << h) - 1, f = l >> 1, c = 23 === i ? Math.pow(2, -24) - Math.pow(2, -77) : 0, d = r ? 0 : a - 1, p = r ? 1 : -1, g = e < 0 || 0 === e && 1 / e < 0 ? 1 : 0; for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (s = isNaN(e) ? 1 : 0, o = l) : (o = Math.floor(Math.log(e) / Math.LN2), e * (u = Math.pow(2, -o)) < 1 && (o--, u *= 2), (e += o + f >= 1 ? c / u : c * Math.pow(2, 1 - f)) * u >= 2 && (o++, u /= 2), o + f >= l ? (s = 0, o = l) : o + f >= 1 ? (s = (e * u - 1) * Math.pow(2, i), o += f) : (s = e * Math.pow(2, f - 1) * Math.pow(2, i), o = 0)); i >= 8; t[n + d] = 255 & s, d += p, s /= 256, i -= 8); for (o = o << i | s, h += i; h > 0; t[n + d] = 255 & o, d += p, o /= 256, h -= 8); t[n + d - p] |= 128 * g } }, function (t, e, n) { "use strict"; var r = {}; (0, n(0).assign)(r, n(30), n(33), n(19)), t.exports = r }, function (t, e, n) { "use strict"; var r = n(31), i = n(0), a = n(17), o = n(8), s = n(18), u = Object.prototype.toString; function h(t) { if (!(this instanceof h)) return new h(t); this.options = i.assign({ level: -1, method: 8, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: 0, to: "" }, t || {}); var e = this.options; e.raw && e.windowBits > 0 ? e.windowBits = -e.windowBits : e.gzip && e.windowBits > 0 && e.windowBits < 16 && (e.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new s, this.strm.avail_out = 0; var n = r.deflateInit2(this.strm, e.level, e.method, e.windowBits, e.memLevel, e.strategy); if (0 !== n) throw new Error(o[n]); if (e.header && r.deflateSetHeader(this.strm, e.header), e.dictionary) { var l; if (l = "string" == typeof e.dictionary ? a.string2buf(e.dictionary) : "[object ArrayBuffer]" === u.call(e.dictionary) ? new Uint8Array(e.dictionary) : e.dictionary, 0 !== (n = r.deflateSetDictionary(this.strm, l))) throw new Error(o[n]); this._dict_set = !0 } } function l(t, e) { var n = new h(e); if (n.push(t, !0), n.err) throw n.msg || o[n.err]; return n.result } h.prototype.push = function (t, e) { var n, o, s = this.strm, h = this.options.chunkSize; if (this.ended) return !1; o = e === ~~e ? e : !0 === e ? 4 : 0, "string" == typeof t ? s.input = a.string2buf(t) : "[object ArrayBuffer]" === u.call(t) ? s.input = new Uint8Array(t) : s.input = t, s.next_in = 0, s.avail_in = s.input.length; do { if (0 === s.avail_out && (s.output = new i.Buf8(h), s.next_out = 0, s.avail_out = h), 1 !== (n = r.deflate(s, o)) && 0 !== n) return this.onEnd(n), this.ended = !0, !1; 0 !== s.avail_out && (0 !== s.avail_in || 4 !== o && 2 !== o) || ("string" === this.options.to ? this.onData(a.buf2binstring(i.shrinkBuf(s.output, s.next_out))) : this.onData(i.shrinkBuf(s.output, s.next_out))) } while ((s.avail_in > 0 || 0 === s.avail_out) && 1 !== n); return 4 === o ? (n = r.deflateEnd(this.strm), this.onEnd(n), this.ended = !0, 0 === n) : 2 !== o || (this.onEnd(0), s.avail_out = 0, !0) }, h.prototype.onData = function (t) { this.chunks.push(t) }, h.prototype.onEnd = function (t) { 0 === t && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = i.flattenChunks(this.chunks)), this.chunks = [], this.err = t, this.msg = this.strm.msg }, e.Deflate = h, e.deflate = l, e.deflateRaw = function (t, e) { return (e = e || {}).raw = !0, l(t, e) }, e.gzip = function (t, e) { return (e = e || {}).gzip = !0, l(t, e) } }, function (t, e, n) { "use strict"; var r, i = n(0), a = n(32), o = n(15), s = n(16), u = n(8); function h(t, e) { return t.msg = u[e], e } function l(t) { return (t << 1) - (t > 4 ? 9 : 0) } function f(t) { for (var e = t.length; --e >= 0;)t[e] = 0 } function c(t) { var e = t.state, n = e.pending; n > t.avail_out && (n = t.avail_out), 0 !== n && (i.arraySet(t.output, e.pending_buf, e.pending_out, n, t.next_out), t.next_out += n, e.pending_out += n, t.total_out += n, t.avail_out -= n, e.pending -= n, 0 === e.pending && (e.pending_out = 0)) } function d(t, e) { a._tr_flush_block(t, t.block_start >= 0 ? t.block_start : -1, t.strstart - t.block_start, e), t.block_start = t.strstart, c(t.strm) } function p(t, e) { t.pending_buf[t.pending++] = e } function g(t, e) { t.pending_buf[t.pending++] = e >>> 8 & 255, t.pending_buf[t.pending++] = 255 & e } function _(t, e) { var n, r, i = t.max_chain_length, a = t.strstart, o = t.prev_length, s = t.nice_match, u = t.strstart > t.w_size - 262 ? t.strstart - (t.w_size - 262) : 0, h = t.window, l = t.w_mask, f = t.prev, c = t.strstart + 258, d = h[a + o - 1], p = h[a + o]; t.prev_length >= t.good_match && (i >>= 2), s > t.lookahead && (s = t.lookahead); do { if (h[(n = e) + o] === p && h[n + o - 1] === d && h[n] === h[a] && h[++n] === h[a + 1]) { a += 2, n++; do { } while (h[++a] === h[++n] && h[++a] === h[++n] && h[++a] === h[++n] && h[++a] === h[++n] && h[++a] === h[++n] && h[++a] === h[++n] && h[++a] === h[++n] && h[++a] === h[++n] && a < c); if (r = 258 - (c - a), a = c - 258, r > o) { if (t.match_start = e, o = r, r >= s) break; d = h[a + o - 1], p = h[a + o] } } } while ((e = f[e & l]) > u && 0 != --i); return o <= t.lookahead ? o : t.lookahead } function m(t) { var e, n, r, a, u, h, l, f, c, d, p = t.w_size; do { if (a = t.window_size - t.lookahead - t.strstart, t.strstart >= p + (p - 262)) { i.arraySet(t.window, t.window, p, p, 0), t.match_start -= p, t.strstart -= p, t.block_start -= p, e = n = t.hash_size; do { r = t.head[--e], t.head[e] = r >= p ? r - p : 0 } while (--n); e = n = p; do { r = t.prev[--e], t.prev[e] = r >= p ? r - p : 0 } while (--n); a += p } if (0 === t.strm.avail_in) break; if (h = t.strm, l = t.window, f = t.strstart + t.lookahead, c = a, d = void 0, (d = h.avail_in) > c && (d = c), n = 0 === d ? 0 : (h.avail_in -= d, i.arraySet(l, h.input, h.next_in, d, f), 1 === h.state.wrap ? h.adler = o(h.adler, l, d, f) : 2 === h.state.wrap && (h.adler = s(h.adler, l, d, f)), h.next_in += d, h.total_in += d, d), t.lookahead += n, t.lookahead + t.insert >= 3) for (u = t.strstart - t.insert, t.ins_h = t.window[u], t.ins_h = (t.ins_h << t.hash_shift ^ t.window[u + 1]) & t.hash_mask; t.insert && (t.ins_h = (t.ins_h << t.hash_shift ^ t.window[u + 3 - 1]) & t.hash_mask, t.prev[u & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = u, u++, t.insert--, !(t.lookahead + t.insert < 3));); } while (t.lookahead < 262 && 0 !== t.strm.avail_in) } function b(t, e) { for (var n, r; ;) { if (t.lookahead < 262) { if (m(t), t.lookahead < 262 && 0 === e) return 1; if (0 === t.lookahead) break } if (n = 0, t.lookahead >= 3 && (t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + 3 - 1]) & t.hash_mask, n = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart), 0 !== n && t.strstart - n <= t.w_size - 262 && (t.match_length = _(t, n)), t.match_length >= 3) if (r = a._tr_tally(t, t.strstart - t.match_start, t.match_length - 3), t.lookahead -= t.match_length, t.match_length <= t.max_lazy_match && t.lookahead >= 3) { t.match_length--; do { t.strstart++, t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + 3 - 1]) & t.hash_mask, n = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart } while (0 != --t.match_length); t.strstart++ } else t.strstart += t.match_length, t.match_length = 0, t.ins_h = t.window[t.strstart], t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + 1]) & t.hash_mask; else r = a._tr_tally(t, 0, t.window[t.strstart]), t.lookahead--, t.strstart++; if (r && (d(t, !1), 0 === t.strm.avail_out)) return 1 } return t.insert = t.strstart < 2 ? t.strstart : 2, 4 === e ? (d(t, !0), 0 === t.strm.avail_out ? 3 : 4) : t.last_lit && (d(t, !1), 0 === t.strm.avail_out) ? 1 : 2 } function w(t, e) { for (var n, r, i; ;) { if (t.lookahead < 262) { if (m(t), t.lookahead < 262 && 0 === e) return 1; if (0 === t.lookahead) break } if (n = 0, t.lookahead >= 3 && (t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + 3 - 1]) & t.hash_mask, n = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart), t.prev_length = t.match_length, t.prev_match = t.match_start, t.match_length = 2, 0 !== n && t.prev_length < t.max_lazy_match && t.strstart - n <= t.w_size - 262 && (t.match_length = _(t, n), t.match_length <= 5 && (1 === t.strategy || 3 === t.match_length && t.strstart - t.match_start > 4096) && (t.match_length = 2)), t.prev_length >= 3 && t.match_length <= t.prev_length) { i = t.strstart + t.lookahead - 3, r = a._tr_tally(t, t.strstart - 1 - t.prev_match, t.prev_length - 3), t.lookahead -= t.prev_length - 1, t.prev_length -= 2; do { ++t.strstart <= i && (t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + 3 - 1]) & t.hash_mask, n = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart) } while (0 != --t.prev_length); if (t.match_available = 0, t.match_length = 2, t.strstart++, r && (d(t, !1), 0 === t.strm.avail_out)) return 1 } else if (t.match_available) { if ((r = a._tr_tally(t, 0, t.window[t.strstart - 1])) && d(t, !1), t.strstart++, t.lookahead--, 0 === t.strm.avail_out) return 1 } else t.match_available = 1, t.strstart++, t.lookahead-- } return t.match_available && (r = a._tr_tally(t, 0, t.window[t.strstart - 1]), t.match_available = 0), t.insert = t.strstart < 2 ? t.strstart : 2, 4 === e ? (d(t, !0), 0 === t.strm.avail_out ? 3 : 4) : t.last_lit && (d(t, !1), 0 === t.strm.avail_out) ? 1 : 2 } function v(t, e, n, r, i) { this.good_length = t, this.max_lazy = e, this.nice_length = n, this.max_chain = r, this.func = i } function y() { this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = 8, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new i.Buf16(1146), this.dyn_dtree = new i.Buf16(122), this.bl_tree = new i.Buf16(78), f(this.dyn_ltree), f(this.dyn_dtree), f(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new i.Buf16(16), this.heap = new i.Buf16(573), f(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new i.Buf16(573), f(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0 } function T(t) { var e; return t && t.state ? (t.total_in = t.total_out = 0, t.data_type = 2, (e = t.state).pending = 0, e.pending_out = 0, e.wrap < 0 && (e.wrap = -e.wrap), e.status = e.wrap ? 42 : 113, t.adler = 2 === e.wrap ? 0 : 1, e.last_flush = 0, a._tr_init(e), 0) : h(t, -2) } function E(t) { var e, n = T(t); return 0 === n && ((e = t.state).window_size = 2 * e.w_size, f(e.head), e.max_lazy_match = r[e.level].max_lazy, e.good_match = r[e.level].good_length, e.nice_match = r[e.level].nice_length, e.max_chain_length = r[e.level].max_chain, e.strstart = 0, e.block_start = 0, e.lookahead = 0, e.insert = 0, e.match_length = e.prev_length = 2, e.match_available = 0, e.ins_h = 0), n } function k(t, e, n, r, a, o) { if (!t) return -2; var s = 1; if (-1 === e && (e = 6), r < 0 ? (s = 0, r = -r) : r > 15 && (s = 2, r -= 16), a < 1 || a > 9 || 8 !== n || r < 8 || r > 15 || e < 0 || e > 9 || o < 0 || o > 4) return h(t, -2); 8 === r && (r = 9); var u = new y; return t.state = u, u.strm = t, u.wrap = s, u.gzhead = null, u.w_bits = r, u.w_size = 1 << u.w_bits, u.w_mask = u.w_size - 1, u.hash_bits = a + 7, u.hash_size = 1 << u.hash_bits, u.hash_mask = u.hash_size - 1, u.hash_shift = ~~((u.hash_bits + 3 - 1) / 3), u.window = new i.Buf8(2 * u.w_size), u.head = new i.Buf16(u.hash_size), u.prev = new i.Buf16(u.w_size), u.lit_bufsize = 1 << a + 6, u.pending_buf_size = 4 * u.lit_bufsize, u.pending_buf = new i.Buf8(u.pending_buf_size), u.d_buf = 1 * u.lit_bufsize, u.l_buf = 3 * u.lit_bufsize, u.level = e, u.strategy = o, u.method = n, E(t) } r = [new v(0, 0, 0, 0, (function (t, e) { var n = 65535; for (n > t.pending_buf_size - 5 && (n = t.pending_buf_size - 5); ;) { if (t.lookahead <= 1) { if (m(t), 0 === t.lookahead && 0 === e) return 1; if (0 === t.lookahead) break } t.strstart += t.lookahead, t.lookahead = 0; var r = t.block_start + n; if ((0 === t.strstart || t.strstart >= r) && (t.lookahead = t.strstart - r, t.strstart = r, d(t, !1), 0 === t.strm.avail_out)) return 1; if (t.strstart - t.block_start >= t.w_size - 262 && (d(t, !1), 0 === t.strm.avail_out)) return 1 } return t.insert = 0, 4 === e ? (d(t, !0), 0 === t.strm.avail_out ? 3 : 4) : (t.strstart > t.block_start && (d(t, !1), t.strm.avail_out), 1) })), new v(4, 4, 8, 4, b), new v(4, 5, 16, 8, b), new v(4, 6, 32, 32, b), new v(4, 4, 16, 16, w), new v(8, 16, 32, 32, w), new v(8, 16, 128, 128, w), new v(8, 32, 128, 256, w), new v(32, 128, 258, 1024, w), new v(32, 258, 258, 4096, w)], e.deflateInit = function (t, e) { return k(t, e, 8, 15, 8, 0) }, e.deflateInit2 = k, e.deflateReset = E, e.deflateResetKeep = T, e.deflateSetHeader = function (t, e) { return t && t.state ? 2 !== t.state.wrap ? -2 : (t.state.gzhead = e, 0) : -2 }, e.deflate = function (t, e) { var n, i, o, u; if (!t || !t.state || e > 5 || e < 0) return t ? h(t, -2) : -2; if (i = t.state, !t.output || !t.input && 0 !== t.avail_in || 666 === i.status && 4 !== e) return h(t, 0 === t.avail_out ? -5 : -2); if (i.strm = t, n = i.last_flush, i.last_flush = e, 42 === i.status) if (2 === i.wrap) t.adler = 0, p(i, 31), p(i, 139), p(i, 8), i.gzhead ? (p(i, (i.gzhead.text ? 1 : 0) + (i.gzhead.hcrc ? 2 : 0) + (i.gzhead.extra ? 4 : 0) + (i.gzhead.name ? 8 : 0) + (i.gzhead.comment ? 16 : 0)), p(i, 255 & i.gzhead.time), p(i, i.gzhead.time >> 8 & 255), p(i, i.gzhead.time >> 16 & 255), p(i, i.gzhead.time >> 24 & 255), p(i, 9 === i.level ? 2 : i.strategy >= 2 || i.level < 2 ? 4 : 0), p(i, 255 & i.gzhead.os), i.gzhead.extra && i.gzhead.extra.length && (p(i, 255 & i.gzhead.extra.length), p(i, i.gzhead.extra.length >> 8 & 255)), i.gzhead.hcrc && (t.adler = s(t.adler, i.pending_buf, i.pending, 0)), i.gzindex = 0, i.status = 69) : (p(i, 0), p(i, 0), p(i, 0), p(i, 0), p(i, 0), p(i, 9 === i.level ? 2 : i.strategy >= 2 || i.level < 2 ? 4 : 0), p(i, 3), i.status = 113); else { var _ = 8 + (i.w_bits - 8 << 4) << 8; _ |= (i.strategy >= 2 || i.level < 2 ? 0 : i.level < 6 ? 1 : 6 === i.level ? 2 : 3) << 6, 0 !== i.strstart && (_ |= 32), _ += 31 - _ % 31, i.status = 113, g(i, _), 0 !== i.strstart && (g(i, t.adler >>> 16), g(i, 65535 & t.adler)), t.adler = 1 } if (69 === i.status) if (i.gzhead.extra) { for (o = i.pending; i.gzindex < (65535 & i.gzhead.extra.length) && (i.pending !== i.pending_buf_size || (i.gzhead.hcrc && i.pending > o && (t.adler = s(t.adler, i.pending_buf, i.pending - o, o)), c(t), o = i.pending, i.pending !== i.pending_buf_size));)p(i, 255 & i.gzhead.extra[i.gzindex]), i.gzindex++; i.gzhead.hcrc && i.pending > o && (t.adler = s(t.adler, i.pending_buf, i.pending - o, o)), i.gzindex === i.gzhead.extra.length && (i.gzindex = 0, i.status = 73) } else i.status = 73; if (73 === i.status) if (i.gzhead.name) { o = i.pending; do { if (i.pending === i.pending_buf_size && (i.gzhead.hcrc && i.pending > o && (t.adler = s(t.adler, i.pending_buf, i.pending - o, o)), c(t), o = i.pending, i.pending === i.pending_buf_size)) { u = 1; break } u = i.gzindex < i.gzhead.name.length ? 255 & i.gzhead.name.charCodeAt(i.gzindex++) : 0, p(i, u) } while (0 !== u); i.gzhead.hcrc && i.pending > o && (t.adler = s(t.adler, i.pending_buf, i.pending - o, o)), 0 === u && (i.gzindex = 0, i.status = 91) } else i.status = 91; if (91 === i.status) if (i.gzhead.comment) { o = i.pending; do { if (i.pending === i.pending_buf_size && (i.gzhead.hcrc && i.pending > o && (t.adler = s(t.adler, i.pending_buf, i.pending - o, o)), c(t), o = i.pending, i.pending === i.pending_buf_size)) { u = 1; break } u = i.gzindex < i.gzhead.comment.length ? 255 & i.gzhead.comment.charCodeAt(i.gzindex++) : 0, p(i, u) } while (0 !== u); i.gzhead.hcrc && i.pending > o && (t.adler = s(t.adler, i.pending_buf, i.pending - o, o)), 0 === u && (i.status = 103) } else i.status = 103; if (103 === i.status && (i.gzhead.hcrc ? (i.pending + 2 > i.pending_buf_size && c(t), i.pending + 2 <= i.pending_buf_size && (p(i, 255 & t.adler), p(i, t.adler >> 8 & 255), t.adler = 0, i.status = 113)) : i.status = 113), 0 !== i.pending) { if (c(t), 0 === t.avail_out) return i.last_flush = -1, 0 } else if (0 === t.avail_in && l(e) <= l(n) && 4 !== e) return h(t, -5); if (666 === i.status && 0 !== t.avail_in) return h(t, -5); if (0 !== t.avail_in || 0 !== i.lookahead || 0 !== e && 666 !== i.status) { var b = 2 === i.strategy ? function (t, e) { for (var n; ;) { if (0 === t.lookahead && (m(t), 0 === t.lookahead)) { if (0 === e) return 1; break } if (t.match_length = 0, n = a._tr_tally(t, 0, t.window[t.strstart]), t.lookahead--, t.strstart++, n && (d(t, !1), 0 === t.strm.avail_out)) return 1 } return t.insert = 0, 4 === e ? (d(t, !0), 0 === t.strm.avail_out ? 3 : 4) : t.last_lit && (d(t, !1), 0 === t.strm.avail_out) ? 1 : 2 }(i, e) : 3 === i.strategy ? function (t, e) { for (var n, r, i, o, s = t.window; ;) { if (t.lookahead <= 258) { if (m(t), t.lookahead <= 258 && 0 === e) return 1; if (0 === t.lookahead) break } if (t.match_length = 0, t.lookahead >= 3 && t.strstart > 0 && (r = s[i = t.strstart - 1]) === s[++i] && r === s[++i] && r === s[++i]) { o = t.strstart + 258; do { } while (r === s[++i] && r === s[++i] && r === s[++i] && r === s[++i] && r === s[++i] && r === s[++i] && r === s[++i] && r === s[++i] && i < o); t.match_length = 258 - (o - i), t.match_length > t.lookahead && (t.match_length = t.lookahead) } if (t.match_length >= 3 ? (n = a._tr_tally(t, 1, t.match_length - 3), t.lookahead -= t.match_length, t.strstart += t.match_length, t.match_length = 0) : (n = a._tr_tally(t, 0, t.window[t.strstart]), t.lookahead--, t.strstart++), n && (d(t, !1), 0 === t.strm.avail_out)) return 1 } return t.insert = 0, 4 === e ? (d(t, !0), 0 === t.strm.avail_out ? 3 : 4) : t.last_lit && (d(t, !1), 0 === t.strm.avail_out) ? 1 : 2 }(i, e) : r[i.level].func(i, e); if (3 !== b && 4 !== b || (i.status = 666), 1 === b || 3 === b) return 0 === t.avail_out && (i.last_flush = -1), 0; if (2 === b && (1 === e ? a._tr_align(i) : 5 !== e && (a._tr_stored_block(i, 0, 0, !1), 3 === e && (f(i.head), 0 === i.lookahead && (i.strstart = 0, i.block_start = 0, i.insert = 0))), c(t), 0 === t.avail_out)) return i.last_flush = -1, 0 } return 4 !== e ? 0 : i.wrap <= 0 ? 1 : (2 === i.wrap ? (p(i, 255 & t.adler), p(i, t.adler >> 8 & 255), p(i, t.adler >> 16 & 255), p(i, t.adler >> 24 & 255), p(i, 255 & t.total_in), p(i, t.total_in >> 8 & 255), p(i, t.total_in >> 16 & 255), p(i, t.total_in >> 24 & 255)) : (g(i, t.adler >>> 16), g(i, 65535 & t.adler)), c(t), i.wrap > 0 && (i.wrap = -i.wrap), 0 !== i.pending ? 0 : 1) }, e.deflateEnd = function (t) { var e; return t && t.state ? 42 !== (e = t.state.status) && 69 !== e && 73 !== e && 91 !== e && 103 !== e && 113 !== e && 666 !== e ? h(t, -2) : (t.state = null, 113 === e ? h(t, -3) : 0) : -2 }, e.deflateSetDictionary = function (t, e) { var n, r, a, s, u, h, l, c, d = e.length; if (!t || !t.state) return -2; if (2 === (s = (n = t.state).wrap) || 1 === s && 42 !== n.status || n.lookahead) return -2; for (1 === s && (t.adler = o(t.adler, e, d, 0)), n.wrap = 0, d >= n.w_size && (0 === s && (f(n.head), n.strstart = 0, n.block_start = 0, n.insert = 0), c = new i.Buf8(n.w_size), i.arraySet(c, e, d - n.w_size, n.w_size, 0), e = c, d = n.w_size), u = t.avail_in, h = t.next_in, l = t.input, t.avail_in = d, t.next_in = 0, t.input = e, m(n); n.lookahead >= 3;) { r = n.strstart, a = n.lookahead - 2; do { n.ins_h = (n.ins_h << n.hash_shift ^ n.window[r + 3 - 1]) & n.hash_mask, n.prev[r & n.w_mask] = n.head[n.ins_h], n.head[n.ins_h] = r, r++ } while (--a); n.strstart = r, n.lookahead = 2, m(n) } return n.strstart += n.lookahead, n.block_start = n.strstart, n.insert = n.lookahead, n.lookahead = 0, n.match_length = n.prev_length = 2, n.match_available = 0, t.next_in = h, t.input = l, t.avail_in = u, n.wrap = s, 0 }, e.deflateInfo = "pako deflate (from Nodeca project)" }, function (t, e, n) { "use strict"; var r = n(0); function i(t) { for (var e = t.length; --e >= 0;)t[e] = 0 } var a = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], o = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], s = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], u = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], h = new Array(576); i(h); var l = new Array(60); i(l); var f = new Array(512); i(f); var c = new Array(256); i(c); var d = new Array(29); i(d); var p, g, _, m = new Array(30); function b(t, e, n, r, i) { this.static_tree = t, this.extra_bits = e, this.extra_base = n, this.elems = r, this.max_length = i, this.has_stree = t && t.length } function w(t, e) { this.dyn_tree = t, this.max_code = 0, this.stat_desc = e } function v(t) { return t < 256 ? f[t] : f[256 + (t >>> 7)] } function y(t, e) { t.pending_buf[t.pending++] = 255 & e, t.pending_buf[t.pending++] = e >>> 8 & 255 } function T(t, e, n) { t.bi_valid > 16 - n ? (t.bi_buf |= e << t.bi_valid & 65535, y(t, t.bi_buf), t.bi_buf = e >> 16 - t.bi_valid, t.bi_valid += n - 16) : (t.bi_buf |= e << t.bi_valid & 65535, t.bi_valid += n) } function E(t, e, n) { T(t, n[2 * e], n[2 * e + 1]) } function k(t, e) { var n = 0; do { n |= 1 & t, t >>>= 1, n <<= 1 } while (--e > 0); return n >>> 1 } function x(t, e, n) { var r, i, a = new Array(16), o = 0; for (r = 1; r <= 15; r++)a[r] = o = o + n[r - 1] << 1; for (i = 0; i <= e; i++) { var s = t[2 * i + 1]; 0 !== s && (t[2 * i] = k(a[s]++, s)) } } function S(t) { var e; for (e = 0; e < 286; e++)t.dyn_ltree[2 * e] = 0; for (e = 0; e < 30; e++)t.dyn_dtree[2 * e] = 0; for (e = 0; e < 19; e++)t.bl_tree[2 * e] = 0; t.dyn_ltree[512] = 1, t.opt_len = t.static_len = 0, t.last_lit = t.matches = 0 } function A(t) { t.bi_valid > 8 ? y(t, t.bi_buf) : t.bi_valid > 0 && (t.pending_buf[t.pending++] = t.bi_buf), t.bi_buf = 0, t.bi_valid = 0 } function N(t, e, n, r) { var i = 2 * e, a = 2 * n; return t[i] < t[a] || t[i] === t[a] && r[e] <= r[n] } function C(t, e, n) { for (var r = t.heap[n], i = n << 1; i <= t.heap_len && (i < t.heap_len && N(e, t.heap[i + 1], t.heap[i], t.depth) && i++, !N(e, r, t.heap[i], t.depth));)t.heap[n] = t.heap[i], n = i, i <<= 1; t.heap[n] = r } function I(t, e, n) { var r, i, s, u, h = 0; if (0 !== t.last_lit) do { r = t.pending_buf[t.d_buf + 2 * h] << 8 | t.pending_buf[t.d_buf + 2 * h + 1], i = t.pending_buf[t.l_buf + h], h++, 0 === r ? E(t, i, e) : (E(t, (s = c[i]) + 256 + 1, e), 0 !== (u = a[s]) && T(t, i -= d[s], u), E(t, s = v(--r), n), 0 !== (u = o[s]) && T(t, r -= m[s], u)) } while (h < t.last_lit); E(t, 256, e) } function R(t, e) { var n, r, i, a = e.dyn_tree, o = e.stat_desc.static_tree, s = e.stat_desc.has_stree, u = e.stat_desc.elems, h = -1; for (t.heap_len = 0, t.heap_max = 573, n = 0; n < u; n++)0 !== a[2 * n] ? (t.heap[++t.heap_len] = h = n, t.depth[n] = 0) : a[2 * n + 1] = 0; for (; t.heap_len < 2;)a[2 * (i = t.heap[++t.heap_len] = h < 2 ? ++h : 0)] = 1, t.depth[i] = 0, t.opt_len--, s && (t.static_len -= o[2 * i + 1]); for (e.max_code = h, n = t.heap_len >> 1; n >= 1; n--)C(t, a, n); i = u; do { n = t.heap[1], t.heap[1] = t.heap[t.heap_len--], C(t, a, 1), r = t.heap[1], t.heap[--t.heap_max] = n, t.heap[--t.heap_max] = r, a[2 * i] = a[2 * n] + a[2 * r], t.depth[i] = (t.depth[n] >= t.depth[r] ? t.depth[n] : t.depth[r]) + 1, a[2 * n + 1] = a[2 * r + 1] = i, t.heap[1] = i++, C(t, a, 1) } while (t.heap_len >= 2); t.heap[--t.heap_max] = t.heap[1], function (t, e) { var n, r, i, a, o, s, u = e.dyn_tree, h = e.max_code, l = e.stat_desc.static_tree, f = e.stat_desc.has_stree, c = e.stat_desc.extra_bits, d = e.stat_desc.extra_base, p = e.stat_desc.max_length, g = 0; for (a = 0; a <= 15; a++)t.bl_count[a] = 0; for (u[2 * t.heap[t.heap_max] + 1] = 0, n = t.heap_max + 1; n < 573; n++)(a = u[2 * u[2 * (r = t.heap[n]) + 1] + 1] + 1) > p && (a = p, g++), u[2 * r + 1] = a, r > h || (t.bl_count[a]++, o = 0, r >= d && (o = c[r - d]), s = u[2 * r], t.opt_len += s * (a + o), f && (t.static_len += s * (l[2 * r + 1] + o))); if (0 !== g) { do { for (a = p - 1; 0 === t.bl_count[a];)a--; t.bl_count[a]--, t.bl_count[a + 1] += 2, t.bl_count[p]--, g -= 2 } while (g > 0); for (a = p; 0 !== a; a--)for (r = t.bl_count[a]; 0 !== r;)(i = t.heap[--n]) > h || (u[2 * i + 1] !== a && (t.opt_len += (a - u[2 * i + 1]) * u[2 * i], u[2 * i + 1] = a), r--) } }(t, e), x(a, h, t.bl_count) } function O(t, e, n) { var r, i, a = -1, o = e[1], s = 0, u = 7, h = 4; for (0 === o && (u = 138, h = 3), e[2 * (n + 1) + 1] = 65535, r = 0; r <= n; r++)i = o, o = e[2 * (r + 1) + 1], ++s < u && i === o || (s < h ? t.bl_tree[2 * i] += s : 0 !== i ? (i !== a && t.bl_tree[2 * i]++, t.bl_tree[32]++) : s <= 10 ? t.bl_tree[34]++ : t.bl_tree[36]++, s = 0, a = i, 0 === o ? (u = 138, h = 3) : i === o ? (u = 6, h = 3) : (u = 7, h = 4)) } function D(t, e, n) { var r, i, a = -1, o = e[1], s = 0, u = 7, h = 4; for (0 === o && (u = 138, h = 3), r = 0; r <= n; r++)if (i = o, o = e[2 * (r + 1) + 1], !(++s < u && i === o)) { if (s < h) do { E(t, i, t.bl_tree) } while (0 != --s); else 0 !== i ? (i !== a && (E(t, i, t.bl_tree), s--), E(t, 16, t.bl_tree), T(t, s - 3, 2)) : s <= 10 ? (E(t, 17, t.bl_tree), T(t, s - 3, 3)) : (E(t, 18, t.bl_tree), T(t, s - 11, 7)); s = 0, a = i, 0 === o ? (u = 138, h = 3) : i === o ? (u = 6, h = 3) : (u = 7, h = 4) } } i(m); var B = !1; function L(t, e, n, i) { T(t, 0 + (i ? 1 : 0), 3), function (t, e, n, i) { A(t), i && (y(t, n), y(t, ~n)), r.arraySet(t.pending_buf, t.window, e, n, t.pending), t.pending += n }(t, e, n, !0) } e._tr_init = function (t) { B || (!function () { var t, e, n, r, i, u = new Array(16); for (n = 0, r = 0; r < 28; r++)for (d[r] = n, t = 0; t < 1 << a[r]; t++)c[n++] = r; for (c[n - 1] = r, i = 0, r = 0; r < 16; r++)for (m[r] = i, t = 0; t < 1 << o[r]; t++)f[i++] = r; for (i >>= 7; r < 30; r++)for (m[r] = i << 7, t = 0; t < 1 << o[r] - 7; t++)f[256 + i++] = r; for (e = 0; e <= 15; e++)u[e] = 0; for (t = 0; t <= 143;)h[2 * t + 1] = 8, t++, u[8]++; for (; t <= 255;)h[2 * t + 1] = 9, t++, u[9]++; for (; t <= 279;)h[2 * t + 1] = 7, t++, u[7]++; for (; t <= 287;)h[2 * t + 1] = 8, t++, u[8]++; for (x(h, 287, u), t = 0; t < 30; t++)l[2 * t + 1] = 5, l[2 * t] = k(t, 5); p = new b(h, a, 257, 286, 15), g = new b(l, o, 0, 30, 15), _ = new b(new Array(0), s, 0, 19, 7) }(), B = !0), t.l_desc = new w(t.dyn_ltree, p), t.d_desc = new w(t.dyn_dtree, g), t.bl_desc = new w(t.bl_tree, _), t.bi_buf = 0, t.bi_valid = 0, S(t) }, e._tr_stored_block = L, e._tr_flush_block = function (t, e, n, r) { var i, a, o = 0; t.level > 0 ? (2 === t.strm.data_type && (t.strm.data_type = function (t) { var e, n = 4093624447; for (e = 0; e <= 31; e++, n >>>= 1)if (1 & n && 0 !== t.dyn_ltree[2 * e]) return 0; if (0 !== t.dyn_ltree[18] || 0 !== t.dyn_ltree[20] || 0 !== t.dyn_ltree[26]) return 1; for (e = 32; e < 256; e++)if (0 !== t.dyn_ltree[2 * e]) return 1; return 0 }(t)), R(t, t.l_desc), R(t, t.d_desc), o = function (t) { var e; for (O(t, t.dyn_ltree, t.l_desc.max_code), O(t, t.dyn_dtree, t.d_desc.max_code), R(t, t.bl_desc), e = 18; e >= 3 && 0 === t.bl_tree[2 * u[e] + 1]; e--); return t.opt_len += 3 * (e + 1) + 5 + 5 + 4, e }(t), i = t.opt_len + 3 + 7 >>> 3, (a = t.static_len + 3 + 7 >>> 3) <= i && (i = a)) : i = a = n + 5, n + 4 <= i && -1 !== e ? L(t, e, n, r) : 4 === t.strategy || a === i ? (T(t, 2 + (r ? 1 : 0), 3), I(t, h, l)) : (T(t, 4 + (r ? 1 : 0), 3), function (t, e, n, r) { var i; for (T(t, e - 257, 5), T(t, n - 1, 5), T(t, r - 4, 4), i = 0; i < r; i++)T(t, t.bl_tree[2 * u[i] + 1], 3); D(t, t.dyn_ltree, e - 1), D(t, t.dyn_dtree, n - 1) }(t, t.l_desc.max_code + 1, t.d_desc.max_code + 1, o + 1), I(t, t.dyn_ltree, t.dyn_dtree)), S(t), r && A(t) }, e._tr_tally = function (t, e, n) { return t.pending_buf[t.d_buf + 2 * t.last_lit] = e >>> 8 & 255, t.pending_buf[t.d_buf + 2 * t.last_lit + 1] = 255 & e, t.pending_buf[t.l_buf + t.last_lit] = 255 & n, t.last_lit++, 0 === e ? t.dyn_ltree[2 * n]++ : (t.matches++, e--, t.dyn_ltree[2 * (c[n] + 256 + 1)]++, t.dyn_dtree[2 * v(e)]++), t.last_lit === t.lit_bufsize - 1 }, e._tr_align = function (t) { T(t, 2, 3), E(t, 256, h), function (t) { 16 === t.bi_valid ? (y(t, t.bi_buf), t.bi_buf = 0, t.bi_valid = 0) : t.bi_valid >= 8 && (t.pending_buf[t.pending++] = 255 & t.bi_buf, t.bi_buf >>= 8, t.bi_valid -= 8) }(t) } }, function (t, e, n) { "use strict"; var r = n(34), i = n(0), a = n(17), o = n(19), s = n(8), u = n(18), h = n(37), l = Object.prototype.toString; function f(t) { if (!(this instanceof f)) return new f(t); this.options = i.assign({ chunkSize: 16384, windowBits: 0, to: "" }, t || {}); var e = this.options; e.raw && e.windowBits >= 0 && e.windowBits < 16 && (e.windowBits = -e.windowBits, 0 === e.windowBits && (e.windowBits = -15)), !(e.windowBits >= 0 && e.windowBits < 16) || t && t.windowBits || (e.windowBits += 32), e.windowBits > 15 && e.windowBits < 48 && 0 == (15 & e.windowBits) && (e.windowBits |= 15), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new u, this.strm.avail_out = 0; var n = r.inflateInit2(this.strm, e.windowBits); if (n !== o.Z_OK) throw new Error(s[n]); if (this.header = new h, r.inflateGetHeader(this.strm, this.header), e.dictionary && ("string" == typeof e.dictionary ? e.dictionary = a.string2buf(e.dictionary) : "[object ArrayBuffer]" === l.call(e.dictionary) && (e.dictionary = new Uint8Array(e.dictionary)), e.raw && (n = r.inflateSetDictionary(this.strm, e.dictionary)) !== o.Z_OK)) throw new Error(s[n]) } function c(t, e) { var n = new f(e); if (n.push(t, !0), n.err) throw n.msg || s[n.err]; return n.result } f.prototype.push = function (t, e) { var n, s, u, h, f, c = this.strm, d = this.options.chunkSize, p = this.options.dictionary, g = !1; if (this.ended) return !1; s = e === ~~e ? e : !0 === e ? o.Z_FINISH : o.Z_NO_FLUSH, "string" == typeof t ? c.input = a.binstring2buf(t) : "[object ArrayBuffer]" === l.call(t) ? c.input = new Uint8Array(t) : c.input = t, c.next_in = 0, c.avail_in = c.input.length; do { if (0 === c.avail_out && (c.output = new i.Buf8(d), c.next_out = 0, c.avail_out = d), (n = r.inflate(c, o.Z_NO_FLUSH)) === o.Z_NEED_DICT && p && (n = r.inflateSetDictionary(this.strm, p)), n === o.Z_BUF_ERROR && !0 === g && (n = o.Z_OK, g = !1), n !== o.Z_STREAM_END && n !== o.Z_OK) return this.onEnd(n), this.ended = !0, !1; c.next_out && (0 !== c.avail_out && n !== o.Z_STREAM_END && (0 !== c.avail_in || s !== o.Z_FINISH && s !== o.Z_SYNC_FLUSH) || ("string" === this.options.to ? (u = a.utf8border(c.output, c.next_out), h = c.next_out - u, f = a.buf2string(c.output, u), c.next_out = h, c.avail_out = d - h, h && i.arraySet(c.output, c.output, u, h, 0), this.onData(f)) : this.onData(i.shrinkBuf(c.output, c.next_out)))), 0 === c.avail_in && 0 === c.avail_out && (g = !0) } while ((c.avail_in > 0 || 0 === c.avail_out) && n !== o.Z_STREAM_END); return n === o.Z_STREAM_END && (s = o.Z_FINISH), s === o.Z_FINISH ? (n = r.inflateEnd(this.strm), this.onEnd(n), this.ended = !0, n === o.Z_OK) : s !== o.Z_SYNC_FLUSH || (this.onEnd(o.Z_OK), c.avail_out = 0, !0) }, f.prototype.onData = function (t) { this.chunks.push(t) }, f.prototype.onEnd = function (t) { t === o.Z_OK && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = i.flattenChunks(this.chunks)), this.chunks = [], this.err = t, this.msg = this.strm.msg }, e.Inflate = f, e.inflate = c, e.inflateRaw = function (t, e) { return (e = e || {}).raw = !0, c(t, e) }, e.ungzip = c }, function (t, e, n) { "use strict"; var r = n(0), i = n(15), a = n(16), o = n(35), s = n(36); function u(t) { return (t >>> 24 & 255) + (t >>> 8 & 65280) + ((65280 & t) << 8) + ((255 & t) << 24) } function h() { this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new r.Buf16(320), this.work = new r.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0 } function l(t) { var e; return t && t.state ? (e = t.state, t.total_in = t.total_out = e.total = 0, t.msg = "", e.wrap && (t.adler = 1 & e.wrap), e.mode = 1, e.last = 0, e.havedict = 0, e.dmax = 32768, e.head = null, e.hold = 0, e.bits = 0, e.lencode = e.lendyn = new r.Buf32(852), e.distcode = e.distdyn = new r.Buf32(592), e.sane = 1, e.back = -1, 0) : -2 } function f(t) { var e; return t && t.state ? ((e = t.state).wsize = 0, e.whave = 0, e.wnext = 0, l(t)) : -2 } function c(t, e) { var n, r; return t && t.state ? (r = t.state, e < 0 ? (n = 0, e = -e) : (n = 1 + (e >> 4), e < 48 && (e &= 15)), e && (e < 8 || e > 15) ? -2 : (null !== r.window && r.wbits !== e && (r.window = null), r.wrap = n, r.wbits = e, f(t))) : -2 } function d(t, e) { var n, r; return t ? (r = new h, t.state = r, r.window = null, 0 !== (n = c(t, e)) && (t.state = null), n) : -2 } var p, g, _ = !0; function m(t) { if (_) { var e; for (p = new r.Buf32(512), g = new r.Buf32(32), e = 0; e < 144;)t.lens[e++] = 8; for (; e < 256;)t.lens[e++] = 9; for (; e < 280;)t.lens[e++] = 7; for (; e < 288;)t.lens[e++] = 8; for (s(1, t.lens, 0, 288, p, 0, t.work, { bits: 9 }), e = 0; e < 32;)t.lens[e++] = 5; s(2, t.lens, 0, 32, g, 0, t.work, { bits: 5 }), _ = !1 } t.lencode = p, t.lenbits = 9, t.distcode = g, t.distbits = 5 } function b(t, e, n, i) { var a, o = t.state; return null === o.window && (o.wsize = 1 << o.wbits, o.wnext = 0, o.whave = 0, o.window = new r.Buf8(o.wsize)), i >= o.wsize ? (r.arraySet(o.window, e, n - o.wsize, o.wsize, 0), o.wnext = 0, o.whave = o.wsize) : ((a = o.wsize - o.wnext) > i && (a = i), r.arraySet(o.window, e, n - i, a, o.wnext), (i -= a) ? (r.arraySet(o.window, e, n - i, i, 0), o.wnext = i, o.whave = o.wsize) : (o.wnext += a, o.wnext === o.wsize && (o.wnext = 0), o.whave < o.wsize && (o.whave += a))), 0 } e.inflateReset = f, e.inflateReset2 = c, e.inflateResetKeep = l, e.inflateInit = function (t) { return d(t, 15) }, e.inflateInit2 = d, e.inflate = function (t, e) { var n, h, l, f, c, d, p, g, _, w, v, y, T, E, k, x, S, A, N, C, I, R, O, D, B = 0, L = new r.Buf8(4), P = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]; if (!t || !t.state || !t.output || !t.input && 0 !== t.avail_in) return -2; 12 === (n = t.state).mode && (n.mode = 13), c = t.next_out, l = t.output, p = t.avail_out, f = t.next_in, h = t.input, d = t.avail_in, g = n.hold, _ = n.bits, w = d, v = p, R = 0; t: for (; ;)switch (n.mode) { case 1: if (0 === n.wrap) { n.mode = 13; break } for (; _ < 16;) { if (0 === d) break t; d--, g += h[f++] << _, _ += 8 } if (2 & n.wrap && 35615 === g) { n.check = 0, L[0] = 255 & g, L[1] = g >>> 8 & 255, n.check = a(n.check, L, 2, 0), g = 0, _ = 0, n.mode = 2; break } if (n.flags = 0, n.head && (n.head.done = !1), !(1 & n.wrap) || (((255 & g) << 8) + (g >> 8)) % 31) { t.msg = "incorrect header check", n.mode = 30; break } if (8 != (15 & g)) { t.msg = "unknown compression method", n.mode = 30; break } if (_ -= 4, I = 8 + (15 & (g >>>= 4)), 0 === n.wbits) n.wbits = I; else if (I > n.wbits) { t.msg = "invalid window size", n.mode = 30; break } n.dmax = 1 << I, t.adler = n.check = 1, n.mode = 512 & g ? 10 : 12, g = 0, _ = 0; break; case 2: for (; _ < 16;) { if (0 === d) break t; d--, g += h[f++] << _, _ += 8 } if (n.flags = g, 8 != (255 & n.flags)) { t.msg = "unknown compression method", n.mode = 30; break } if (57344 & n.flags) { t.msg = "unknown header flags set", n.mode = 30; break } n.head && (n.head.text = g >> 8 & 1), 512 & n.flags && (L[0] = 255 & g, L[1] = g >>> 8 & 255, n.check = a(n.check, L, 2, 0)), g = 0, _ = 0, n.mode = 3; case 3: for (; _ < 32;) { if (0 === d) break t; d--, g += h[f++] << _, _ += 8 } n.head && (n.head.time = g), 512 & n.flags && (L[0] = 255 & g, L[1] = g >>> 8 & 255, L[2] = g >>> 16 & 255, L[3] = g >>> 24 & 255, n.check = a(n.check, L, 4, 0)), g = 0, _ = 0, n.mode = 4; case 4: for (; _ < 16;) { if (0 === d) break t; d--, g += h[f++] << _, _ += 8 } n.head && (n.head.xflags = 255 & g, n.head.os = g >> 8), 512 & n.flags && (L[0] = 255 & g, L[1] = g >>> 8 & 255, n.check = a(n.check, L, 2, 0)), g = 0, _ = 0, n.mode = 5; case 5: if (1024 & n.flags) { for (; _ < 16;) { if (0 === d) break t; d--, g += h[f++] << _, _ += 8 } n.length = g, n.head && (n.head.extra_len = g), 512 & n.flags && (L[0] = 255 & g, L[1] = g >>> 8 & 255, n.check = a(n.check, L, 2, 0)), g = 0, _ = 0 } else n.head && (n.head.extra = null); n.mode = 6; case 6: if (1024 & n.flags && ((y = n.length) > d && (y = d), y && (n.head && (I = n.head.extra_len - n.length, n.head.extra || (n.head.extra = new Array(n.head.extra_len)), r.arraySet(n.head.extra, h, f, y, I)), 512 & n.flags && (n.check = a(n.check, h, y, f)), d -= y, f += y, n.length -= y), n.length)) break t; n.length = 0, n.mode = 7; case 7: if (2048 & n.flags) { if (0 === d) break t; y = 0; do { I = h[f + y++], n.head && I && n.length < 65536 && (n.head.name += String.fromCharCode(I)) } while (I && y < d); if (512 & n.flags && (n.check = a(n.check, h, y, f)), d -= y, f += y, I) break t } else n.head && (n.head.name = null); n.length = 0, n.mode = 8; case 8: if (4096 & n.flags) { if (0 === d) break t; y = 0; do { I = h[f + y++], n.head && I && n.length < 65536 && (n.head.comment += String.fromCharCode(I)) } while (I && y < d); if (512 & n.flags && (n.check = a(n.check, h, y, f)), d -= y, f += y, I) break t } else n.head && (n.head.comment = null); n.mode = 9; case 9: if (512 & n.flags) { for (; _ < 16;) { if (0 === d) break t; d--, g += h[f++] << _, _ += 8 } if (g !== (65535 & n.check)) { t.msg = "header crc mismatch", n.mode = 30; break } g = 0, _ = 0 } n.head && (n.head.hcrc = n.flags >> 9 & 1, n.head.done = !0), t.adler = n.check = 0, n.mode = 12; break; case 10: for (; _ < 32;) { if (0 === d) break t; d--, g += h[f++] << _, _ += 8 } t.adler = n.check = u(g), g = 0, _ = 0, n.mode = 11; case 11: if (0 === n.havedict) return t.next_out = c, t.avail_out = p, t.next_in = f, t.avail_in = d, n.hold = g, n.bits = _, 2; t.adler = n.check = 1, n.mode = 12; case 12: if (5 === e || 6 === e) break t; case 13: if (n.last) { g >>>= 7 & _, _ -= 7 & _, n.mode = 27; break } for (; _ < 3;) { if (0 === d) break t; d--, g += h[f++] << _, _ += 8 } switch (n.last = 1 & g, _ -= 1, 3 & (g >>>= 1)) { case 0: n.mode = 14; break; case 1: if (m(n), n.mode = 20, 6 === e) { g >>>= 2, _ -= 2; break t } break; case 2: n.mode = 17; break; case 3: t.msg = "invalid block type", n.mode = 30 }g >>>= 2, _ -= 2; break; case 14: for (g >>>= 7 & _, _ -= 7 & _; _ < 32;) { if (0 === d) break t; d--, g += h[f++] << _, _ += 8 } if ((65535 & g) != (g >>> 16 ^ 65535)) { t.msg = "invalid stored block lengths", n.mode = 30; break } if (n.length = 65535 & g, g = 0, _ = 0, n.mode = 15, 6 === e) break t; case 15: n.mode = 16; case 16: if (y = n.length) { if (y > d && (y = d), y > p && (y = p), 0 === y) break t; r.arraySet(l, h, f, y, c), d -= y, f += y, p -= y, c += y, n.length -= y; break } n.mode = 12; break; case 17: for (; _ < 14;) { if (0 === d) break t; d--, g += h[f++] << _, _ += 8 } if (n.nlen = 257 + (31 & g), g >>>= 5, _ -= 5, n.ndist = 1 + (31 & g), g >>>= 5, _ -= 5, n.ncode = 4 + (15 & g), g >>>= 4, _ -= 4, n.nlen > 286 || n.ndist > 30) { t.msg = "too many length or distance symbols", n.mode = 30; break } n.have = 0, n.mode = 18; case 18: for (; n.have < n.ncode;) { for (; _ < 3;) { if (0 === d) break t; d--, g += h[f++] << _, _ += 8 } n.lens[P[n.have++]] = 7 & g, g >>>= 3, _ -= 3 } for (; n.have < 19;)n.lens[P[n.have++]] = 0; if (n.lencode = n.lendyn, n.lenbits = 7, O = { bits: n.lenbits }, R = s(0, n.lens, 0, 19, n.lencode, 0, n.work, O), n.lenbits = O.bits, R) { t.msg = "invalid code lengths set", n.mode = 30; break } n.have = 0, n.mode = 19; case 19: for (; n.have < n.nlen + n.ndist;) { for (; x = (B = n.lencode[g & (1 << n.lenbits) - 1]) >>> 16 & 255, S = 65535 & B, !((k = B >>> 24) <= _);) { if (0 === d) break t; d--, g += h[f++] << _, _ += 8 } if (S < 16) g >>>= k, _ -= k, n.lens[n.have++] = S; else { if (16 === S) { for (D = k + 2; _ < D;) { if (0 === d) break t; d--, g += h[f++] << _, _ += 8 } if (g >>>= k, _ -= k, 0 === n.have) { t.msg = "invalid bit length repeat", n.mode = 30; break } I = n.lens[n.have - 1], y = 3 + (3 & g), g >>>= 2, _ -= 2 } else if (17 === S) { for (D = k + 3; _ < D;) { if (0 === d) break t; d--, g += h[f++] << _, _ += 8 } _ -= k, I = 0, y = 3 + (7 & (g >>>= k)), g >>>= 3, _ -= 3 } else { for (D = k + 7; _ < D;) { if (0 === d) break t; d--, g += h[f++] << _, _ += 8 } _ -= k, I = 0, y = 11 + (127 & (g >>>= k)), g >>>= 7, _ -= 7 } if (n.have + y > n.nlen + n.ndist) { t.msg = "invalid bit length repeat", n.mode = 30; break } for (; y--;)n.lens[n.have++] = I } } if (30 === n.mode) break; if (0 === n.lens[256]) { t.msg = "invalid code -- missing end-of-block", n.mode = 30; break } if (n.lenbits = 9, O = { bits: n.lenbits }, R = s(1, n.lens, 0, n.nlen, n.lencode, 0, n.work, O), n.lenbits = O.bits, R) { t.msg = "invalid literal/lengths set", n.mode = 30; break } if (n.distbits = 6, n.distcode = n.distdyn, O = { bits: n.distbits }, R = s(2, n.lens, n.nlen, n.ndist, n.distcode, 0, n.work, O), n.distbits = O.bits, R) { t.msg = "invalid distances set", n.mode = 30; break } if (n.mode = 20, 6 === e) break t; case 20: n.mode = 21; case 21: if (d >= 6 && p >= 258) { t.next_out = c, t.avail_out = p, t.next_in = f, t.avail_in = d, n.hold = g, n.bits = _, o(t, v), c = t.next_out, l = t.output, p = t.avail_out, f = t.next_in, h = t.input, d = t.avail_in, g = n.hold, _ = n.bits, 12 === n.mode && (n.back = -1); break } for (n.back = 0; x = (B = n.lencode[g & (1 << n.lenbits) - 1]) >>> 16 & 255, S = 65535 & B, !((k = B >>> 24) <= _);) { if (0 === d) break t; d--, g += h[f++] << _, _ += 8 } if (x && 0 == (240 & x)) { for (A = k, N = x, C = S; x = (B = n.lencode[C + ((g & (1 << A + N) - 1) >> A)]) >>> 16 & 255, S = 65535 & B, !(A + (k = B >>> 24) <= _);) { if (0 === d) break t; d--, g += h[f++] << _, _ += 8 } g >>>= A, _ -= A, n.back += A } if (g >>>= k, _ -= k, n.back += k, n.length = S, 0 === x) { n.mode = 26; break } if (32 & x) { n.back = -1, n.mode = 12; break } if (64 & x) { t.msg = "invalid literal/length code", n.mode = 30; break } n.extra = 15 & x, n.mode = 22; case 22: if (n.extra) { for (D = n.extra; _ < D;) { if (0 === d) break t; d--, g += h[f++] << _, _ += 8 } n.length += g & (1 << n.extra) - 1, g >>>= n.extra, _ -= n.extra, n.back += n.extra } n.was = n.length, n.mode = 23; case 23: for (; x = (B = n.distcode[g & (1 << n.distbits) - 1]) >>> 16 & 255, S = 65535 & B, !((k = B >>> 24) <= _);) { if (0 === d) break t; d--, g += h[f++] << _, _ += 8 } if (0 == (240 & x)) { for (A = k, N = x, C = S; x = (B = n.distcode[C + ((g & (1 << A + N) - 1) >> A)]) >>> 16 & 255, S = 65535 & B, !(A + (k = B >>> 24) <= _);) { if (0 === d) break t; d--, g += h[f++] << _, _ += 8 } g >>>= A, _ -= A, n.back += A } if (g >>>= k, _ -= k, n.back += k, 64 & x) { t.msg = "invalid distance code", n.mode = 30; break } n.offset = S, n.extra = 15 & x, n.mode = 24; case 24: if (n.extra) { for (D = n.extra; _ < D;) { if (0 === d) break t; d--, g += h[f++] << _, _ += 8 } n.offset += g & (1 << n.extra) - 1, g >>>= n.extra, _ -= n.extra, n.back += n.extra } if (n.offset > n.dmax) { t.msg = "invalid distance too far back", n.mode = 30; break } n.mode = 25; case 25: if (0 === p) break t; if (y = v - p, n.offset > y) { if ((y = n.offset - y) > n.whave && n.sane) { t.msg = "invalid distance too far back", n.mode = 30; break } y > n.wnext ? (y -= n.wnext, T = n.wsize - y) : T = n.wnext - y, y > n.length && (y = n.length), E = n.window } else E = l, T = c - n.offset, y = n.length; y > p && (y = p), p -= y, n.length -= y; do { l[c++] = E[T++] } while (--y); 0 === n.length && (n.mode = 21); break; case 26: if (0 === p) break t; l[c++] = n.length, p--, n.mode = 21; break; case 27: if (n.wrap) { for (; _ < 32;) { if (0 === d) break t; d--, g |= h[f++] << _, _ += 8 } if (v -= p, t.total_out += v, n.total += v, v && (t.adler = n.check = n.flags ? a(n.check, l, v, c - v) : i(n.check, l, v, c - v)), v = p, (n.flags ? g : u(g)) !== n.check) { t.msg = "incorrect data check", n.mode = 30; break } g = 0, _ = 0 } n.mode = 28; case 28: if (n.wrap && n.flags) { for (; _ < 32;) { if (0 === d) break t; d--, g += h[f++] << _, _ += 8 } if (g !== (4294967295 & n.total)) { t.msg = "incorrect length check", n.mode = 30; break } g = 0, _ = 0 } n.mode = 29; case 29: R = 1; break t; case 30: R = -3; break t; case 31: return -4; case 32: default: return -2 }return t.next_out = c, t.avail_out = p, t.next_in = f, t.avail_in = d, n.hold = g, n.bits = _, (n.wsize || v !== t.avail_out && n.mode < 30 && (n.mode < 27 || 4 !== e)) && b(t, t.output, t.next_out, v - t.avail_out) ? (n.mode = 31, -4) : (w -= t.avail_in, v -= t.avail_out, t.total_in += w, t.total_out += v, n.total += v, n.wrap && v && (t.adler = n.check = n.flags ? a(n.check, l, v, t.next_out - v) : i(n.check, l, v, t.next_out - v)), t.data_type = n.bits + (n.last ? 64 : 0) + (12 === n.mode ? 128 : 0) + (20 === n.mode || 15 === n.mode ? 256 : 0), (0 === w && 0 === v || 4 === e) && 0 === R && (R = -5), R) }, e.inflateEnd = function (t) { if (!t || !t.state) return -2; var e = t.state; return e.window && (e.window = null), t.state = null, 0 }, e.inflateGetHeader = function (t, e) { var n; return t && t.state ? 0 == (2 & (n = t.state).wrap) ? -2 : (n.head = e, e.done = !1, 0) : -2 }, e.inflateSetDictionary = function (t, e) { var n, r = e.length; return t && t.state ? 0 !== (n = t.state).wrap && 11 !== n.mode ? -2 : 11 === n.mode && i(1, e, r, 0) !== n.check ? -3 : b(t, e, r, r) ? (n.mode = 31, -4) : (n.havedict = 1, 0) : -2 }, e.inflateInfo = "pako inflate (from Nodeca project)" }, function (t, e, n) { "use strict"; t.exports = function (t, e) { var n, r, i, a, o, s, u, h, l, f, c, d, p, g, _, m, b, w, v, y, T, E, k, x, S; n = t.state, r = t.next_in, x = t.input, i = r + (t.avail_in - 5), a = t.next_out, S = t.output, o = a - (e - t.avail_out), s = a + (t.avail_out - 257), u = n.dmax, h = n.wsize, l = n.whave, f = n.wnext, c = n.window, d = n.hold, p = n.bits, g = n.lencode, _ = n.distcode, m = (1 << n.lenbits) - 1, b = (1 << n.distbits) - 1; t: do { p < 15 && (d += x[r++] << p, p += 8, d += x[r++] << p, p += 8), w = g[d & m]; e: for (; ;) { if (d >>>= v = w >>> 24, p -= v, 0 === (v = w >>> 16 & 255)) S[a++] = 65535 & w; else { if (!(16 & v)) { if (0 == (64 & v)) { w = g[(65535 & w) + (d & (1 << v) - 1)]; continue e } if (32 & v) { n.mode = 12; break t } t.msg = "invalid literal/length code", n.mode = 30; break t } y = 65535 & w, (v &= 15) && (p < v && (d += x[r++] << p, p += 8), y += d & (1 << v) - 1, d >>>= v, p -= v), p < 15 && (d += x[r++] << p, p += 8, d += x[r++] << p, p += 8), w = _[d & b]; n: for (; ;) { if (d >>>= v = w >>> 24, p -= v, !(16 & (v = w >>> 16 & 255))) { if (0 == (64 & v)) { w = _[(65535 & w) + (d & (1 << v) - 1)]; continue n } t.msg = "invalid distance code", n.mode = 30; break t } if (T = 65535 & w, p < (v &= 15) && (d += x[r++] << p, (p += 8) < v && (d += x[r++] << p, p += 8)), (T += d & (1 << v) - 1) > u) { t.msg = "invalid distance too far back", n.mode = 30; break t } if (d >>>= v, p -= v, T > (v = a - o)) { if ((v = T - v) > l && n.sane) { t.msg = "invalid distance too far back", n.mode = 30; break t } if (E = 0, k = c, 0 === f) { if (E += h - v, v < y) { y -= v; do { S[a++] = c[E++] } while (--v); E = a - T, k = S } } else if (f < v) { if (E += h + f - v, (v -= f) < y) { y -= v; do { S[a++] = c[E++] } while (--v); if (E = 0, f < y) { y -= v = f; do { S[a++] = c[E++] } while (--v); E = a - T, k = S } } } else if (E += f - v, v < y) { y -= v; do { S[a++] = c[E++] } while (--v); E = a - T, k = S } for (; y > 2;)S[a++] = k[E++], S[a++] = k[E++], S[a++] = k[E++], y -= 3; y && (S[a++] = k[E++], y > 1 && (S[a++] = k[E++])) } else { E = a - T; do { S[a++] = S[E++], S[a++] = S[E++], S[a++] = S[E++], y -= 3 } while (y > 2); y && (S[a++] = S[E++], y > 1 && (S[a++] = S[E++])) } break } } break } } while (r < i && a < s); r -= y = p >> 3, d &= (1 << (p -= y << 3)) - 1, t.next_in = r, t.next_out = a, t.avail_in = r < i ? i - r + 5 : 5 - (r - i), t.avail_out = a < s ? s - a + 257 : 257 - (a - s), n.hold = d, n.bits = p } }, function (t, e, n) { "use strict"; var r = n(0), i = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], a = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], o = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], s = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64]; t.exports = function (t, e, n, u, h, l, f, c) { var d, p, g, _, m, b, w, v, y, T = c.bits, E = 0, k = 0, x = 0, S = 0, A = 0, N = 0, C = 0, I = 0, R = 0, O = 0, D = null, B = 0, L = new r.Buf16(16), P = new r.Buf16(16), M = null, U = 0; for (E = 0; E <= 15; E++)L[E] = 0; for (k = 0; k < u; k++)L[e[n + k]]++; for (A = T, S = 15; S >= 1 && 0 === L[S]; S--); if (A > S && (A = S), 0 === S) return h[l++] = 20971520, h[l++] = 20971520, c.bits = 1, 0; for (x = 1; x < S && 0 === L[x]; x++); for (A < x && (A = x), I = 1, E = 1; E <= 15; E++)if (I <<= 1, (I -= L[E]) < 0) return -1; if (I > 0 && (0 === t || 1 !== S)) return -1; for (P[1] = 0, E = 1; E < 15; E++)P[E + 1] = P[E] + L[E]; for (k = 0; k < u; k++)0 !== e[n + k] && (f[P[e[n + k]]++] = k); if (0 === t ? (D = M = f, b = 19) : 1 === t ? (D = i, B -= 257, M = a, U -= 257, b = 256) : (D = o, M = s, b = -1), O = 0, k = 0, E = x, m = l, N = A, C = 0, g = -1, _ = (R = 1 << A) - 1, 1 === t && R > 852 || 2 === t && R > 592) return 1; for (; ;) { w = E - C, f[k] < b ? (v = 0, y = f[k]) : f[k] > b ? (v = M[U + f[k]], y = D[B + f[k]]) : (v = 96, y = 0), d = 1 << E - C, x = p = 1 << N; do { h[m + (O >> C) + (p -= d)] = w << 24 | v << 16 | y | 0 } while (0 !== p); for (d = 1 << E - 1; O & d;)d >>= 1; if (0 !== d ? (O &= d - 1, O += d) : O = 0, k++, 0 == --L[E]) { if (E === S) break; E = e[n + f[k]] } if (E > A && (O & _) !== g) { for (0 === C && (C = A), m += x, I = 1 << (N = E - C); N + C < S && !((I -= L[N + C]) <= 0);)N++, I <<= 1; if (R += 1 << N, 1 === t && R > 852 || 2 === t && R > 592) return 1; h[g = O & _] = A << 24 | N << 16 | m - l | 0 } } return 0 !== O && (h[m + O] = E - C << 24 | 64 << 16 | 0), c.bits = A, 0 } }, function (t, e, n) { "use strict"; t.exports = function () { this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1 } }, function (t, e, n) { (function (e) { !function () { var r; if (t.exports && !e.xmldocAssumeBrowser) r = n(39); else if (!(r = this.sax)) throw new Error("Expected sax to be defined. Make sure you're including sax.js before this file."); function i(t) { var e = h[h.length - 1].parser; this.name = t.name, this.attr = t.attributes, this.val = "", this.children = [], this.firstChild = null, this.lastChild = null, this.line = e.line, this.column = e.column, this.position = e.position, this.startTagPosition = e.startTagPosition } function a(t) { this.text = t } function o(t) { this.cdata = t } function s(t) { this.comment = t } function u(t) { if (t && (t = t.toString().trim()), !t) throw new Error("No XML to parse!"); var e; this.doctype = "", this.parser = r.parser(!0), (e = this.parser).onopentag = l, e.onclosetag = f, e.ontext = c, e.oncdata = d, e.oncomment = p, e.ondoctype = g, e.onerror = _, h = [this], this.parser.write(t), delete this.parser } i.prototype._addChild = function (t) { this.children.push(t), this.firstChild || (this.firstChild = t), this.lastChild = t }, i.prototype._opentag = function (t) { var e = new i(t); this._addChild(e), h.unshift(e) }, i.prototype._closetag = function () { h.shift() }, i.prototype._text = function (t) { void 0 !== this.children && (this.val += t, this._addChild(new a(t))) }, i.prototype._cdata = function (t) { this.val += t, this._addChild(new o(t)) }, i.prototype._comment = function (t) { void 0 !== this.children && this._addChild(new s(t)) }, i.prototype._error = function (t) { throw t }, i.prototype.eachChild = function (t, e) { for (var n = 0, r = this.children.length; n < r; n++)if ("element" === this.children[n].type && !1 === t.call(e, this.children[n], n, this.children)) return }, i.prototype.childNamed = function (t) { for (var e = 0, n = this.children.length; e < n; e++) { var r = this.children[e]; if (r.name === t) return r } }, i.prototype.childrenNamed = function (t) { for (var e = [], n = 0, r = this.children.length; n < r; n++)this.children[n].name === t && e.push(this.children[n]); return e }, i.prototype.childWithAttribute = function (t, e) { for (var n = 0, r = this.children.length; n < r; n++) { var i = this.children[n]; if ("element" === i.type && (e && i.attr[t] === e || !e && i.attr[t])) return i } }, i.prototype.descendantWithPath = function (t) { for (var e = this, n = t.split("."), r = 0, i = n.length; r < i; r++) { if (!e || "element" !== e.type) return; e = e.childNamed(n[r]) } return e }, i.prototype.valueWithPath = function (t) { var e = t.split("@"), n = this.descendantWithPath(e[0]); return n ? e.length > 1 ? n.attr[e[1]] : n.val : void 0 }, i.prototype.toString = function (t) { return this.toStringWithIndent("", t) }, i.prototype.toStringWithIndent = function (t, e) { var n = t + "<" + this.name, r = e && e.compressed ? "" : "\n"; e && e.preserveWhitespace; for (var i in this.attr) Object.prototype.hasOwnProperty.call(this.attr, i) && (n += " " + i + '="' + m(this.attr[i]) + '"'); if (1 === this.children.length && "element" !== this.children[0].type) n += ">" + this.children[0].toString(e) + "</" + this.name + ">"; else if (this.children.length) { n += ">" + r; for (var a = t + (e && e.compressed ? "" : "  "), o = 0, s = this.children.length; o < s; o++)n += this.children[o].toStringWithIndent(a, e) + r; n += t + "</" + this.name + ">" } else if (e && e.html) { -1 !== ["area", "base", "br", "col", "embed", "frame", "hr", "img", "input", "keygen", "link", "menuitem", "meta", "param", "source", "track", "wbr"].indexOf(this.name) ? n += "/>" : n += "></" + this.name + ">" } else n += "/>"; return n }, a.prototype.toString = function (t) { return b(m(this.text), t) }, a.prototype.toStringWithIndent = function (t, e) { return t + this.toString(e) }, o.prototype.toString = function (t) { return "<![CDATA[" + b(this.cdata, t) + "]]>" }, o.prototype.toStringWithIndent = function (t, e) { return t + this.toString(e) }, s.prototype.toString = function (t) { return "\x3c!--" + b(m(this.comment), t) + "--\x3e" }, s.prototype.toStringWithIndent = function (t, e) { return t + this.toString(e) }, i.prototype.type = "element", a.prototype.type = "text", o.prototype.type = "cdata", s.prototype.type = "comment", function (t, e) { for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]) }(u.prototype, i.prototype), u.prototype._opentag = function (t) { void 0 === this.children ? i.call(this, t) : i.prototype._opentag.apply(this, arguments) }, u.prototype._doctype = function (t) { this.doctype += t }; var h = null; function l() { h[0] && h[0]._opentag.apply(h[0], arguments) } function f() { h[0] && h[0]._closetag.apply(h[0], arguments) } function c() { h[0] && h[0]._text.apply(h[0], arguments) } function d() { h[0] && h[0]._cdata.apply(h[0], arguments) } function p() { h[0] && h[0]._comment.apply(h[0], arguments) } function g() { h[0] && h[0]._doctype.apply(h[0], arguments) } function _() { h[0] && h[0]._error.apply(h[0], arguments) } function m(t) { return t.toString().replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/'/g, "&apos;").replace(/"/g, "&quot;") } function b(t, e) { var n = t; return e && e.trimmed && t.length > 25 && (n = n.substring(0, 25).trim() + ""), e && e.preserveWhitespace || (n = n.trim()), n } t.exports && !e.xmldocAssumeBrowser ? t.exports.XmlDocument = u : this.XmlDocument = u }() }).call(this, n(1)) }, function (t, e, n) {
        (function (t) {
            !function (e) {
                e.parser = function (t, e) { return new a(t, e) }, e.SAXParser = a, e.SAXStream = s, e.createStream = function (t, e) { return new s(t, e) }, e.MAX_BUFFER_LENGTH = 65536; var r, i = ["comment", "sgmlDecl", "textNode", "tagName", "doctype", "procInstName", "procInstBody", "entity", "attribName", "attribValue", "cdata", "script"]; function a(t, n) { if (!(this instanceof a)) return new a(t, n); !function (t) { for (var e = 0, n = i.length; e < n; e++)t[i[e]] = "" }(this), this.q = this.c = "", this.bufferCheckPosition = e.MAX_BUFFER_LENGTH, this.opt = n || {}, this.opt.lowercase = this.opt.lowercase || this.opt.lowercasetags, this.looseCase = this.opt.lowercase ? "toLowerCase" : "toUpperCase", this.tags = [], this.closed = this.closedRoot = this.sawRoot = !1, this.tag = this.error = null, this.strict = !!t, this.noscript = !(!t && !this.opt.noscript), this.state = T.BEGIN, this.strictEntities = this.opt.strictEntities, this.ENTITIES = this.strictEntities ? Object.create(e.XML_ENTITIES) : Object.create(e.ENTITIES), this.attribList = [], this.opt.xmlns && (this.ns = Object.create(h)), this.trackPosition = !1 !== this.opt.position, this.trackPosition && (this.position = this.line = this.column = 0), k(this, "onready") } e.EVENTS = ["text", "processinginstruction", "sgmldeclaration", "doctype", "comment", "opentagstart", "attribute", "opentag", "closetag", "opencdata", "cdata", "closecdata", "error", "end", "ready", "script", "opennamespace", "closenamespace"], Object.create || (Object.create = function (t) { function e() { } return e.prototype = t, new e }), Object.keys || (Object.keys = function (t) { var e = []; for (var n in t) t.hasOwnProperty(n) && e.push(n); return e }), a.prototype = {
                    end: function () { C(this) }, write: function (t) { if (this.error) throw this.error; if (this.closed) return N(this, "Cannot write after close. Assign an onready handler."); if (null === t) return C(this); "object" == typeof t && (t = t.toString()); var n = 0, r = ""; for (; r = U(t, n++), this.c = r, r;)switch (this.trackPosition && (this.position++, "\n" === r ? (this.line++, this.column = 0) : this.column++), this.state) { case T.BEGIN: if (this.state = T.BEGIN_WHITESPACE, "\ufeff" === r) continue; M(this, r); continue; case T.BEGIN_WHITESPACE: M(this, r); continue; case T.TEXT: if (this.sawRoot && !this.closedRoot) { for (var a = n - 1; r && "<" !== r && "&" !== r;)(r = U(t, n++)) && this.trackPosition && (this.position++, "\n" === r ? (this.line++, this.column = 0) : this.column++); this.textNode += t.substring(a, n - 1) } "<" !== r || this.sawRoot && this.closedRoot && !this.strict ? (p(r) || this.sawRoot && !this.closedRoot || I(this, "Text data outside of root node."), "&" === r ? this.state = T.TEXT_ENTITY : this.textNode += r) : (this.state = T.OPEN_WAKA, this.startTagPosition = this.position); continue; case T.SCRIPT: "<" === r ? this.state = T.SCRIPT_ENDING : this.script += r; continue; case T.SCRIPT_ENDING: "/" === r ? this.state = T.CLOSE_TAG : (this.script += "<" + r, this.state = T.SCRIPT); continue; case T.OPEN_WAKA: if ("!" === r) this.state = T.SGML_DECL, this.sgmlDecl = ""; else if (p(r)); else if (m(l, r)) this.state = T.OPEN_TAG, this.tagName = r; else if ("/" === r) this.state = T.CLOSE_TAG, this.tagName = ""; else if ("?" === r) this.state = T.PROC_INST, this.procInstName = this.procInstBody = ""; else { if (I(this, "Unencoded <"), this.startTagPosition + 1 < this.position) { var o = this.position - this.startTagPosition; r = new Array(o).join(" ") + r } this.textNode += "<" + r, this.state = T.TEXT } continue; case T.SGML_DECL: "[CDATA[" === (this.sgmlDecl + r).toUpperCase() ? (x(this, "onopencdata"), this.state = T.CDATA, this.sgmlDecl = "", this.cdata = "") : this.sgmlDecl + r === "--" ? (this.state = T.COMMENT, this.comment = "", this.sgmlDecl = "") : "DOCTYPE" === (this.sgmlDecl + r).toUpperCase() ? (this.state = T.DOCTYPE, (this.doctype || this.sawRoot) && I(this, "Inappropriately located doctype declaration"), this.doctype = "", this.sgmlDecl = "") : ">" === r ? (x(this, "onsgmldeclaration", this.sgmlDecl), this.sgmlDecl = "", this.state = T.TEXT) : g(r) ? (this.state = T.SGML_DECL_QUOTED, this.sgmlDecl += r) : this.sgmlDecl += r; continue; case T.SGML_DECL_QUOTED: r === this.q && (this.state = T.SGML_DECL, this.q = ""), this.sgmlDecl += r; continue; case T.DOCTYPE: ">" === r ? (this.state = T.TEXT, x(this, "ondoctype", this.doctype), this.doctype = !0) : (this.doctype += r, "[" === r ? this.state = T.DOCTYPE_DTD : g(r) && (this.state = T.DOCTYPE_QUOTED, this.q = r)); continue; case T.DOCTYPE_QUOTED: this.doctype += r, r === this.q && (this.q = "", this.state = T.DOCTYPE); continue; case T.DOCTYPE_DTD: this.doctype += r, "]" === r ? this.state = T.DOCTYPE : g(r) && (this.state = T.DOCTYPE_DTD_QUOTED, this.q = r); continue; case T.DOCTYPE_DTD_QUOTED: this.doctype += r, r === this.q && (this.state = T.DOCTYPE_DTD, this.q = ""); continue; case T.COMMENT: "-" === r ? this.state = T.COMMENT_ENDING : this.comment += r; continue; case T.COMMENT_ENDING: "-" === r ? (this.state = T.COMMENT_ENDED, this.comment = A(this.opt, this.comment), this.comment && x(this, "oncomment", this.comment), this.comment = "") : (this.comment += "-" + r, this.state = T.COMMENT); continue; case T.COMMENT_ENDED: ">" !== r ? (I(this, "Malformed comment"), this.comment += "--" + r, this.state = T.COMMENT) : this.state = T.TEXT; continue; case T.CDATA: "]" === r ? this.state = T.CDATA_ENDING : this.cdata += r; continue; case T.CDATA_ENDING: "]" === r ? this.state = T.CDATA_ENDING_2 : (this.cdata += "]" + r, this.state = T.CDATA); continue; case T.CDATA_ENDING_2: ">" === r ? (this.cdata && x(this, "oncdata", this.cdata), x(this, "onclosecdata"), this.cdata = "", this.state = T.TEXT) : "]" === r ? this.cdata += "]" : (this.cdata += "]]" + r, this.state = T.CDATA); continue; case T.PROC_INST: "?" === r ? this.state = T.PROC_INST_ENDING : p(r) ? this.state = T.PROC_INST_BODY : this.procInstName += r; continue; case T.PROC_INST_BODY: if (!this.procInstBody && p(r)) continue; "?" === r ? this.state = T.PROC_INST_ENDING : this.procInstBody += r; continue; case T.PROC_INST_ENDING: ">" === r ? (x(this, "onprocessinginstruction", { name: this.procInstName, body: this.procInstBody }), this.procInstName = this.procInstBody = "", this.state = T.TEXT) : (this.procInstBody += "?" + r, this.state = T.PROC_INST_BODY); continue; case T.OPEN_TAG: m(f, r) ? this.tagName += r : (R(this), ">" === r ? B(this) : "/" === r ? this.state = T.OPEN_TAG_SLASH : (p(r) || I(this, "Invalid character in tag name"), this.state = T.ATTRIB)); continue; case T.OPEN_TAG_SLASH: ">" === r ? (B(this, !0), L(this)) : (I(this, "Forward-slash in opening tag not followed by >"), this.state = T.ATTRIB); continue; case T.ATTRIB: if (p(r)) continue; ">" === r ? B(this) : "/" === r ? this.state = T.OPEN_TAG_SLASH : m(l, r) ? (this.attribName = r, this.attribValue = "", this.state = T.ATTRIB_NAME) : I(this, "Invalid attribute name"); continue; case T.ATTRIB_NAME: "=" === r ? this.state = T.ATTRIB_VALUE : ">" === r ? (I(this, "Attribute without value"), this.attribValue = this.attribName, D(this), B(this)) : p(r) ? this.state = T.ATTRIB_NAME_SAW_WHITE : m(f, r) ? this.attribName += r : I(this, "Invalid attribute name"); continue; case T.ATTRIB_NAME_SAW_WHITE: if ("=" === r) this.state = T.ATTRIB_VALUE; else { if (p(r)) continue; I(this, "Attribute without value"), this.tag.attributes[this.attribName] = "", this.attribValue = "", x(this, "onattribute", { name: this.attribName, value: "" }), this.attribName = "", ">" === r ? B(this) : m(l, r) ? (this.attribName = r, this.state = T.ATTRIB_NAME) : (I(this, "Invalid attribute name"), this.state = T.ATTRIB) } continue; case T.ATTRIB_VALUE: if (p(r)) continue; g(r) ? (this.q = r, this.state = T.ATTRIB_VALUE_QUOTED) : (I(this, "Unquoted attribute value"), this.state = T.ATTRIB_VALUE_UNQUOTED, this.attribValue = r); continue; case T.ATTRIB_VALUE_QUOTED: if (r !== this.q) { "&" === r ? this.state = T.ATTRIB_VALUE_ENTITY_Q : this.attribValue += r; continue } D(this), this.q = "", this.state = T.ATTRIB_VALUE_CLOSED; continue; case T.ATTRIB_VALUE_CLOSED: p(r) ? this.state = T.ATTRIB : ">" === r ? B(this) : "/" === r ? this.state = T.OPEN_TAG_SLASH : m(l, r) ? (I(this, "No whitespace between attributes"), this.attribName = r, this.attribValue = "", this.state = T.ATTRIB_NAME) : I(this, "Invalid attribute name"); continue; case T.ATTRIB_VALUE_UNQUOTED: if (!_(r)) { "&" === r ? this.state = T.ATTRIB_VALUE_ENTITY_U : this.attribValue += r; continue } D(this), ">" === r ? B(this) : this.state = T.ATTRIB; continue; case T.CLOSE_TAG: if (this.tagName) ">" === r ? L(this) : m(f, r) ? this.tagName += r : this.script ? (this.script += "</" + this.tagName, this.tagName = "", this.state = T.SCRIPT) : (p(r) || I(this, "Invalid tagname in closing tag"), this.state = T.CLOSE_TAG_SAW_WHITE); else { if (p(r)) continue; b(l, r) ? this.script ? (this.script += "</" + r, this.state = T.SCRIPT) : I(this, "Invalid tagname in closing tag.") : this.tagName = r } continue; case T.CLOSE_TAG_SAW_WHITE: if (p(r)) continue; ">" === r ? L(this) : I(this, "Invalid characters in closing tag"); continue; case T.TEXT_ENTITY: case T.ATTRIB_VALUE_ENTITY_Q: case T.ATTRIB_VALUE_ENTITY_U: var s, u; switch (this.state) { case T.TEXT_ENTITY: s = T.TEXT, u = "textNode"; break; case T.ATTRIB_VALUE_ENTITY_Q: s = T.ATTRIB_VALUE_QUOTED, u = "attribValue"; break; case T.ATTRIB_VALUE_ENTITY_U: s = T.ATTRIB_VALUE_UNQUOTED, u = "attribValue" }";" === r ? (this[u] += P(this), this.entity = "", this.state = s) : m(this.entity.length ? d : c, r) ? this.entity += r : (I(this, "Invalid character in entity name"), this[u] += "&" + this.entity + r, this.entity = "", this.state = s); continue; default: throw new Error(this, "Unknown state: " + this.state) }this.position >= this.bufferCheckPosition && function (t) { for (var n = Math.max(e.MAX_BUFFER_LENGTH, 10), r = 0, a = 0, o = i.length; a < o; a++) { var s = t[i[a]].length; if (s > n) switch (i[a]) { case "textNode": S(t); break; case "cdata": x(t, "oncdata", t.cdata), t.cdata = ""; break; case "script": x(t, "onscript", t.script), t.script = ""; break; default: N(t, "Max buffer length exceeded: " + i[a]) }r = Math.max(r, s) } var u = e.MAX_BUFFER_LENGTH - r; t.bufferCheckPosition = u + t.position }(this); return this }
/*! http://mths.be/fromcodepoint v0.1.0 by @mathias */, resume: function () { return this.error = null, this }, close: function () { return this.write(null) }, flush: function () { var t; S(t = this), "" !== t.cdata && (x(t, "oncdata", t.cdata), t.cdata = ""), "" !== t.script && (x(t, "onscript", t.script), t.script = "") }
                }; try { r = n(40).Stream } catch (t) { r = function () { } } var o = e.EVENTS.filter((function (t) { return "error" !== t && "end" !== t })); function s(t, e) { if (!(this instanceof s)) return new s(t, e); r.apply(this), this._parser = new a(t, e), this.writable = !0, this.readable = !0; var n = this; this._parser.onend = function () { n.emit("end") }, this._parser.onerror = function (t) { n.emit("error", t), n._parser.error = null }, this._decoder = null, o.forEach((function (t) { Object.defineProperty(n, "on" + t, { get: function () { return n._parser["on" + t] }, set: function (e) { if (!e) return n.removeAllListeners(t), n._parser["on" + t] = e, e; n.on(t, e) }, enumerable: !0, configurable: !1 }) })) } s.prototype = Object.create(r.prototype, { constructor: { value: s } }), s.prototype.write = function (e) { if ("function" == typeof t && "function" == typeof t.isBuffer && t.isBuffer(e)) { if (!this._decoder) { var r = n(13).StringDecoder; this._decoder = new r("utf8") } e = this._decoder.write(e) } return this._parser.write(e.toString()), this.emit("data", e), !0 }, s.prototype.end = function (t) { return t && t.length && this.write(t), this._parser.end(), !0 }, s.prototype.on = function (t, e) { var n = this; return n._parser["on" + t] || -1 === o.indexOf(t) || (n._parser["on" + t] = function () { var e = 1 === arguments.length ? [arguments[0]] : Array.apply(null, arguments); e.splice(0, 0, t), n.emit.apply(n, e) }), r.prototype.on.call(n, t, e) }; var u = "http://www.w3.org/XML/1998/namespace", h = { xml: u, xmlns: "http://www.w3.org/2000/xmlns/" }, l = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, f = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/, c = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, d = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/; function p(t) { return " " === t || "\n" === t || "\r" === t || "\t" === t } function g(t) { return '"' === t || "'" === t } function _(t) { return ">" === t || p(t) } function m(t, e) { return t.test(e) } function b(t, e) { return !m(t, e) } var w, v, y, T = 0; for (var E in e.STATE = { BEGIN: T++, BEGIN_WHITESPACE: T++, TEXT: T++, TEXT_ENTITY: T++, OPEN_WAKA: T++, SGML_DECL: T++, SGML_DECL_QUOTED: T++, DOCTYPE: T++, DOCTYPE_QUOTED: T++, DOCTYPE_DTD: T++, DOCTYPE_DTD_QUOTED: T++, COMMENT_STARTING: T++, COMMENT: T++, COMMENT_ENDING: T++, COMMENT_ENDED: T++, CDATA: T++, CDATA_ENDING: T++, CDATA_ENDING_2: T++, PROC_INST: T++, PROC_INST_BODY: T++, PROC_INST_ENDING: T++, OPEN_TAG: T++, OPEN_TAG_SLASH: T++, ATTRIB: T++, ATTRIB_NAME: T++, ATTRIB_NAME_SAW_WHITE: T++, ATTRIB_VALUE: T++, ATTRIB_VALUE_QUOTED: T++, ATTRIB_VALUE_CLOSED: T++, ATTRIB_VALUE_UNQUOTED: T++, ATTRIB_VALUE_ENTITY_Q: T++, ATTRIB_VALUE_ENTITY_U: T++, CLOSE_TAG: T++, CLOSE_TAG_SAW_WHITE: T++, SCRIPT: T++, SCRIPT_ENDING: T++ }, e.XML_ENTITIES = { amp: "&", gt: ">", lt: "<", quot: '"', apos: "'" }, e.ENTITIES = { amp: "&", gt: ">", lt: "<", quot: '"', apos: "'", AElig: 198, Aacute: 193, Acirc: 194, Agrave: 192, Aring: 197, Atilde: 195, Auml: 196, Ccedil: 199, ETH: 208, Eacute: 201, Ecirc: 202, Egrave: 200, Euml: 203, Iacute: 205, Icirc: 206, Igrave: 204, Iuml: 207, Ntilde: 209, Oacute: 211, Ocirc: 212, Ograve: 210, Oslash: 216, Otilde: 213, Ouml: 214, THORN: 222, Uacute: 218, Ucirc: 219, Ugrave: 217, Uuml: 220, Yacute: 221, aacute: 225, acirc: 226, aelig: 230, agrave: 224, aring: 229, atilde: 227, auml: 228, ccedil: 231, eacute: 233, ecirc: 234, egrave: 232, eth: 240, euml: 235, iacute: 237, icirc: 238, igrave: 236, iuml: 239, ntilde: 241, oacute: 243, ocirc: 244, ograve: 242, oslash: 248, otilde: 245, ouml: 246, szlig: 223, thorn: 254, uacute: 250, ucirc: 251, ugrave: 249, uuml: 252, yacute: 253, yuml: 255, copy: 169, reg: 174, nbsp: 160, iexcl: 161, cent: 162, pound: 163, curren: 164, yen: 165, brvbar: 166, sect: 167, uml: 168, ordf: 170, laquo: 171, not: 172, shy: 173, macr: 175, deg: 176, plusmn: 177, sup1: 185, sup2: 178, sup3: 179, acute: 180, micro: 181, para: 182, middot: 183, cedil: 184, ordm: 186, raquo: 187, frac14: 188, frac12: 189, frac34: 190, iquest: 191, times: 215, divide: 247, OElig: 338, oelig: 339, Scaron: 352, scaron: 353, Yuml: 376, fnof: 402, circ: 710, tilde: 732, Alpha: 913, Beta: 914, Gamma: 915, Delta: 916, Epsilon: 917, Zeta: 918, Eta: 919, Theta: 920, Iota: 921, Kappa: 922, Lambda: 923, Mu: 924, Nu: 925, Xi: 926, Omicron: 927, Pi: 928, Rho: 929, Sigma: 931, Tau: 932, Upsilon: 933, Phi: 934, Chi: 935, Psi: 936, Omega: 937, alpha: 945, beta: 946, gamma: 947, delta: 948, epsilon: 949, zeta: 950, eta: 951, theta: 952, iota: 953, kappa: 954, lambda: 955, mu: 956, nu: 957, xi: 958, omicron: 959, pi: 960, rho: 961, sigmaf: 962, sigma: 963, tau: 964, upsilon: 965, phi: 966, chi: 967, psi: 968, omega: 969, thetasym: 977, upsih: 978, piv: 982, ensp: 8194, emsp: 8195, thinsp: 8201, zwnj: 8204, zwj: 8205, lrm: 8206, rlm: 8207, ndash: 8211, mdash: 8212, lsquo: 8216, rsquo: 8217, sbquo: 8218, ldquo: 8220, rdquo: 8221, bdquo: 8222, dagger: 8224, Dagger: 8225, bull: 8226, hellip: 8230, permil: 8240, prime: 8242, Prime: 8243, lsaquo: 8249, rsaquo: 8250, oline: 8254, frasl: 8260, euro: 8364, image: 8465, weierp: 8472, real: 8476, trade: 8482, alefsym: 8501, larr: 8592, uarr: 8593, rarr: 8594, darr: 8595, harr: 8596, crarr: 8629, lArr: 8656, uArr: 8657, rArr: 8658, dArr: 8659, hArr: 8660, forall: 8704, part: 8706, exist: 8707, empty: 8709, nabla: 8711, isin: 8712, notin: 8713, ni: 8715, prod: 8719, sum: 8721, minus: 8722, lowast: 8727, radic: 8730, prop: 8733, infin: 8734, ang: 8736, and: 8743, or: 8744, cap: 8745, cup: 8746, int: 8747, there4: 8756, sim: 8764, cong: 8773, asymp: 8776, ne: 8800, equiv: 8801, le: 8804, ge: 8805, sub: 8834, sup: 8835, nsub: 8836, sube: 8838, supe: 8839, oplus: 8853, otimes: 8855, perp: 8869, sdot: 8901, lceil: 8968, rceil: 8969, lfloor: 8970, rfloor: 8971, lang: 9001, rang: 9002, loz: 9674, spades: 9824, clubs: 9827, hearts: 9829, diams: 9830 }, Object.keys(e.ENTITIES).forEach((function (t) { var n = e.ENTITIES[t], r = "number" == typeof n ? String.fromCharCode(n) : n; e.ENTITIES[t] = r })), e.STATE) e.STATE[e.STATE[E]] = E; function k(t, e, n) { t[e] && t[e](n) } function x(t, e, n) { t.textNode && S(t), k(t, e, n) } function S(t) { t.textNode = A(t.opt, t.textNode), t.textNode && k(t, "ontext", t.textNode), t.textNode = "" } function A(t, e) { return t.trim && (e = e.trim()), t.normalize && (e = e.replace(/\s+/g, " ")), e } function N(t, e) { return S(t), t.trackPosition && (e += "\nLine: " + t.line + "\nColumn: " + t.column + "\nChar: " + t.c), e = new Error(e), t.error = e, k(t, "onerror", e), t } function C(t) { return t.sawRoot && !t.closedRoot && I(t, "Unclosed root tag"), t.state !== T.BEGIN && t.state !== T.BEGIN_WHITESPACE && t.state !== T.TEXT && N(t, "Unexpected end"), S(t), t.c = "", t.closed = !0, k(t, "onend"), a.call(t, t.strict, t.opt), t } function I(t, e) { if ("object" != typeof t || !(t instanceof a)) throw new Error("bad call to strictFail"); t.strict && N(t, e) } function R(t) { t.strict || (t.tagName = t.tagName[t.looseCase]()); var e = t.tags[t.tags.length - 1] || t, n = t.tag = { name: t.tagName, attributes: {} }; t.opt.xmlns && (n.ns = e.ns), t.attribList.length = 0, x(t, "onopentagstart", n) } function O(t, e) { var n = t.indexOf(":") < 0 ? ["", t] : t.split(":"), r = n[0], i = n[1]; return e && "xmlns" === t && (r = "xmlns", i = ""), { prefix: r, local: i } } function D(t) { if (t.strict || (t.attribName = t.attribName[t.looseCase]()), -1 !== t.attribList.indexOf(t.attribName) || t.tag.attributes.hasOwnProperty(t.attribName)) t.attribName = t.attribValue = ""; else { if (t.opt.xmlns) { var e = O(t.attribName, !0), n = e.prefix, r = e.local; if ("xmlns" === n) if ("xml" === r && t.attribValue !== u) I(t, "xml: prefix must be bound to " + u + "\nActual: " + t.attribValue); else if ("xmlns" === r && "http://www.w3.org/2000/xmlns/" !== t.attribValue) I(t, "xmlns: prefix must be bound to http://www.w3.org/2000/xmlns/\nActual: " + t.attribValue); else { var i = t.tag, a = t.tags[t.tags.length - 1] || t; i.ns === a.ns && (i.ns = Object.create(a.ns)), i.ns[r] = t.attribValue } t.attribList.push([t.attribName, t.attribValue]) } else t.tag.attributes[t.attribName] = t.attribValue, x(t, "onattribute", { name: t.attribName, value: t.attribValue }); t.attribName = t.attribValue = "" } } function B(t, e) { if (t.opt.xmlns) { var n = t.tag, r = O(t.tagName); n.prefix = r.prefix, n.local = r.local, n.uri = n.ns[r.prefix] || "", n.prefix && !n.uri && (I(t, "Unbound namespace prefix: " + JSON.stringify(t.tagName)), n.uri = r.prefix); var i = t.tags[t.tags.length - 1] || t; n.ns && i.ns !== n.ns && Object.keys(n.ns).forEach((function (e) { x(t, "onopennamespace", { prefix: e, uri: n.ns[e] }) })); for (var a = 0, o = t.attribList.length; a < o; a++) { var s = t.attribList[a], u = s[0], h = s[1], l = O(u, !0), f = l.prefix, c = l.local, d = "" === f ? "" : n.ns[f] || "", p = { name: u, value: h, prefix: f, local: c, uri: d }; f && "xmlns" !== f && !d && (I(t, "Unbound namespace prefix: " + JSON.stringify(f)), p.uri = f), t.tag.attributes[u] = p, x(t, "onattribute", p) } t.attribList.length = 0 } t.tag.isSelfClosing = !!e, t.sawRoot = !0, t.tags.push(t.tag), x(t, "onopentag", t.tag), e || (t.noscript || "script" !== t.tagName.toLowerCase() ? t.state = T.TEXT : t.state = T.SCRIPT, t.tag = null, t.tagName = ""), t.attribName = t.attribValue = "", t.attribList.length = 0 } function L(t) { if (!t.tagName) return I(t, "Weird empty close tag."), t.textNode += "</>", void (t.state = T.TEXT); if (t.script) { if ("script" !== t.tagName) return t.script += "</" + t.tagName + ">", t.tagName = "", void (t.state = T.SCRIPT); x(t, "onscript", t.script), t.script = "" } var e = t.tags.length, n = t.tagName; t.strict || (n = n[t.looseCase]()); for (var r = n; e--;) { if (t.tags[e].name === r) break; I(t, "Unexpected close tag") } if (e < 0) return I(t, "Unmatched closing tag: " + t.tagName), t.textNode += "</" + t.tagName + ">", void (t.state = T.TEXT); t.tagName = n; for (var i = t.tags.length; i-- > e;) { var a = t.tag = t.tags.pop(); t.tagName = t.tag.name, x(t, "onclosetag", t.tagName); var o = {}; for (var s in a.ns) o[s] = a.ns[s]; var u = t.tags[t.tags.length - 1] || t; t.opt.xmlns && a.ns !== u.ns && Object.keys(a.ns).forEach((function (e) { var n = a.ns[e]; x(t, "onclosenamespace", { prefix: e, uri: n }) })) } 0 === e && (t.closedRoot = !0), t.tagName = t.attribValue = t.attribName = "", t.attribList.length = 0, t.state = T.TEXT } function P(t) { var e, n = t.entity, r = n.toLowerCase(), i = ""; return t.ENTITIES[n] ? t.ENTITIES[n] : t.ENTITIES[r] ? t.ENTITIES[r] : ("#" === (n = r).charAt(0) && ("x" === n.charAt(1) ? (n = n.slice(2), i = (e = parseInt(n, 16)).toString(16)) : (n = n.slice(1), i = (e = parseInt(n, 10)).toString(10))), n = n.replace(/^0+/, ""), isNaN(e) || i.toLowerCase() !== n ? (I(t, "Invalid character entity"), "&" + t.entity + ";") : String.fromCodePoint(e)) } function M(t, e) { "<" === e ? (t.state = T.OPEN_WAKA, t.startTagPosition = t.position) : p(e) || (I(t, "Non-whitespace before first tag."), t.textNode = e, t.state = T.TEXT) } function U(t, e) { var n = ""; return e < t.length && (n = t.charAt(e)), n } T = e.STATE, String.fromCodePoint || (w = String.fromCharCode, v = Math.floor, y = function () { var t, e, n = 16384, r = [], i = -1, a = arguments.length; if (!a) return ""; for (var o = ""; ++i < a;) { var s = Number(arguments[i]); if (!isFinite(s) || s < 0 || s > 1114111 || v(s) !== s) throw RangeError("Invalid code point: " + s); s <= 65535 ? r.push(s) : (t = 55296 + ((s -= 65536) >> 10), e = s % 1024 + 56320, r.push(t, e)), (i + 1 === a || r.length > n) && (o += w.apply(null, r), r.length = 0) } return o }, Object.defineProperty ? Object.defineProperty(String, "fromCodePoint", { value: y, configurable: !0, writable: !0 }) : String.fromCodePoint = y)
            }(e)
        }).call(this, n(4).Buffer)
    }, function (t, e, n) { t.exports = i; var r = n(9).EventEmitter; function i() { r.call(this) } n(3)(i, r), i.Readable = n(10), i.Writable = n(49), i.Duplex = n(50), i.Transform = n(51), i.PassThrough = n(52), i.Stream = i, i.prototype.pipe = function (t, e) { var n = this; function i(e) { t.writable && !1 === t.write(e) && n.pause && n.pause() } function a() { n.readable && n.resume && n.resume() } n.on("data", i), t.on("drain", a), t._isStdio || e && !1 === e.end || (n.on("end", s), n.on("close", u)); var o = !1; function s() { o || (o = !0, t.end()) } function u() { o || (o = !0, "function" == typeof t.destroy && t.destroy()) } function h(t) { if (l(), 0 === r.listenerCount(this, "error")) throw t } function l() { n.removeListener("data", i), t.removeListener("drain", a), n.removeListener("end", s), n.removeListener("close", u), n.removeListener("error", h), t.removeListener("error", h), n.removeListener("end", l), n.removeListener("close", l), t.removeListener("close", l) } return n.on("error", h), t.on("error", h), n.on("end", l), n.on("close", l), t.on("close", l), t.emit("pipe", n), t } }, function (t, e) { }, function (t, e, n) { "use strict"; var r = n(11).Buffer, i = n(43); t.exports = function () { function t() { !function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, t), this.head = null, this.tail = null, this.length = 0 } return t.prototype.push = function (t) { var e = { data: t, next: null }; this.length > 0 ? this.tail.next = e : this.head = e, this.tail = e, ++this.length }, t.prototype.unshift = function (t) { var e = { data: t, next: this.head }; 0 === this.length && (this.tail = e), this.head = e, ++this.length }, t.prototype.shift = function () { if (0 !== this.length) { var t = this.head.data; return 1 === this.length ? this.head = this.tail = null : this.head = this.head.next, --this.length, t } }, t.prototype.clear = function () { this.head = this.tail = null, this.length = 0 }, t.prototype.join = function (t) { if (0 === this.length) return ""; for (var e = this.head, n = "" + e.data; e = e.next;)n += t + e.data; return n }, t.prototype.concat = function (t) { if (0 === this.length) return r.alloc(0); if (1 === this.length) return this.head.data; for (var e, n, i, a = r.allocUnsafe(t >>> 0), o = this.head, s = 0; o;)e = o.data, n = a, i = s, e.copy(n, i), s += o.data.length, o = o.next; return a }, t }(), i && i.inspect && i.inspect.custom && (t.exports.prototype[i.inspect.custom] = function () { var t = i.inspect({ length: this.length }); return this.constructor.name + " " + t }) }, function (t, e) { }, function (t, e, n) { (function (t) { var r = void 0 !== t && t || "undefined" != typeof self && self || window, i = Function.prototype.apply; function a(t, e) { this._id = t, this._clearFn = e } e.setTimeout = function () { return new a(i.call(setTimeout, r, arguments), clearTimeout) }, e.setInterval = function () { return new a(i.call(setInterval, r, arguments), clearInterval) }, e.clearTimeout = e.clearInterval = function (t) { t && t.close() }, a.prototype.unref = a.prototype.ref = function () { }, a.prototype.close = function () { this._clearFn.call(r, this._id) }, e.enroll = function (t, e) { clearTimeout(t._idleTimeoutId), t._idleTimeout = e }, e.unenroll = function (t) { clearTimeout(t._idleTimeoutId), t._idleTimeout = -1 }, e._unrefActive = e.active = function (t) { clearTimeout(t._idleTimeoutId); var e = t._idleTimeout; e >= 0 && (t._idleTimeoutId = setTimeout((function () { t._onTimeout && t._onTimeout() }), e)) }, n(45), e.setImmediate = "undefined" != typeof self && self.setImmediate || void 0 !== t && t.setImmediate || this && this.setImmediate, e.clearImmediate = "undefined" != typeof self && self.clearImmediate || void 0 !== t && t.clearImmediate || this && this.clearImmediate }).call(this, n(1)) }, function (t, e, n) { (function (t, e) { !function (t, n) { "use strict"; if (!t.setImmediate) { var r, i, a, o, s, u = 1, h = {}, l = !1, f = t.document, c = Object.getPrototypeOf && Object.getPrototypeOf(t); c = c && c.setTimeout ? c : t, "[object process]" === {}.toString.call(t.process) ? r = function (t) { e.nextTick((function () { p(t) })) } : !function () { if (t.postMessage && !t.importScripts) { var e = !0, n = t.onmessage; return t.onmessage = function () { e = !1 }, t.postMessage("", "*"), t.onmessage = n, e } }() ? t.MessageChannel ? ((a = new MessageChannel).port1.onmessage = function (t) { p(t.data) }, r = function (t) { a.port2.postMessage(t) }) : f && "onreadystatechange" in f.createElement("script") ? (i = f.documentElement, r = function (t) { var e = f.createElement("script"); e.onreadystatechange = function () { p(t), e.onreadystatechange = null, i.removeChild(e), e = null }, i.appendChild(e) }) : r = function (t) { setTimeout(p, 0, t) } : (o = "setImmediate$" + Math.random() + "$", s = function (e) { e.source === t && "string" == typeof e.data && 0 === e.data.indexOf(o) && p(+e.data.slice(o.length)) }, t.addEventListener ? t.addEventListener("message", s, !1) : t.attachEvent("onmessage", s), r = function (e) { t.postMessage(o + e, "*") }), c.setImmediate = function (t) { "function" != typeof t && (t = new Function("" + t)); for (var e = new Array(arguments.length - 1), n = 0; n < e.length; n++)e[n] = arguments[n + 1]; var i = { callback: t, args: e }; return h[u] = i, r(u), u++ }, c.clearImmediate = d } function d(t) { delete h[t] } function p(t) { if (l) setTimeout(p, 0, t); else { var e = h[t]; if (e) { l = !0; try { !function (t) { var e = t.callback, n = t.args; switch (n.length) { case 0: e(); break; case 1: e(n[0]); break; case 2: e(n[0], n[1]); break; case 3: e(n[0], n[1], n[2]); break; default: e.apply(void 0, n) } }(e) } finally { d(t), l = !1 } } } } }("undefined" == typeof self ? void 0 === t ? this : t : self) }).call(this, n(1), n(6)) }, function (t, e, n) { (function (e) { function n(t) { try { if (!e.localStorage) return !1 } catch (t) { return !1 } var n = e.localStorage[t]; return null != n && "true" === String(n).toLowerCase() } t.exports = function (t, e) { if (n("noDeprecation")) return t; var r = !1; return function () { if (!r) { if (n("throwDeprecation")) throw new Error(e); n("traceDeprecation") ? console.trace(e) : console.warn(e), r = !0 } return t.apply(this, arguments) } } }).call(this, n(1)) }, function (t, e, n) { var r = n(4), i = r.Buffer; function a(t, e) { for (var n in t) e[n] = t[n] } function o(t, e, n) { return i(t, e, n) } i.from && i.alloc && i.allocUnsafe && i.allocUnsafeSlow ? t.exports = r : (a(r, e), e.Buffer = o), o.prototype = Object.create(i.prototype), a(i, o), o.from = function (t, e, n) { if ("number" == typeof t) throw new TypeError("Argument must not be a number"); return i(t, e, n) }, o.alloc = function (t, e, n) { if ("number" != typeof t) throw new TypeError("Argument must be a number"); var r = i(t); return void 0 !== e ? "string" == typeof n ? r.fill(e, n) : r.fill(e) : r.fill(0), r }, o.allocUnsafe = function (t) { if ("number" != typeof t) throw new TypeError("Argument must be a number"); return i(t) }, o.allocUnsafeSlow = function (t) { if ("number" != typeof t) throw new TypeError("Argument must be a number"); return r.SlowBuffer(t) } }, function (t, e, n) { "use strict"; t.exports = a; var r = n(24), i = Object.create(n(5)); function a(t) { if (!(this instanceof a)) return new a(t); r.call(this, t) } i.inherits = n(3), i.inherits(a, r), a.prototype._transform = function (t, e, n) { n(null, t) } }, function (t, e, n) { t.exports = n(12) }, function (t, e, n) { t.exports = n(2) }, function (t, e, n) { t.exports = n(10).Transform }, function (t, e, n) { t.exports = n(10).PassThrough }, function (t, e, n) { "use strict"; t.exports = function (t, e, n) { var r = (n = n || {}).marker || "`", i = r.charCodeAt(0), a = (r.length, n.validate || function (t) { return t.trim().split(" ", 2)[0] === e }); n.render; t.block.ruler.before("fence", e, (function (t, n, r, o) { var s, u, h, l, f, c, d, p = !1, g = t.bMarks[n] + t.tShift[n], _ = t.eMarks[n]; if (t.sCount[n] - t.blkIndent >= 4) return !1; if (g + 3 > _) return !1; if ((s = t.src.charCodeAt(g)) !== i) return !1; if (f = g, (u = (g = t.skipChars(g, s)) - f) < 3) return !1; if (d = t.src.slice(f, g), h = t.src.slice(g, _), !a(h, d)) return !1; if (s === i && h.indexOf(String.fromCharCode(s)) >= 0) return !1; if (o) return !0; for (l = n; !(++l >= r) && !((g = f = t.bMarks[l] + t.tShift[l]) < (_ = t.eMarks[l]) && t.sCount[l] < t.blkIndent);)if (t.src.charCodeAt(g) === i && !(t.sCount[l] - t.blkIndent >= 4 || (g = t.skipChars(g, s)) - f < u || (g = t.skipSpaces(g)) < _)) { p = !0; break } return u = t.sCount[n], t.line = l + (p ? 1 : 0), (c = t.push(e, "div", 0)).info = h, c.content = t.getLines(n + 1, l, u, !0), c.markup = d, c.map = [n + 1, t.line], !0 }), { alt: ["paragraph", "reference", "blockquote"] }), t.renderer.rules[e] = n.render } }])
}));
//# sourceMappingURL=markdown-it-drawio-viewer.js.map